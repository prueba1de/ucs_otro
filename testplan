!!!!    4    0    1 1706060850   0000                                         
!!!!    4    0    1 1624628116   0000
!test monitor
!Testplan for 73-18922-05_B0 003:54 2021
! AUTOFILE 3432
Name_Mod$ = "DC-PINEDROPS"
! SN: FDO2445069H    GOLDEN BOARD
!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!
!                          _                       _                        !
!                         | |                     | |                       !
!                         | |                     | |                       !
!                    _    | |    _           _    | |    _                  !
!                   | |   | |   | |         | |   | |   | |                 !
!              _    | |   | |   | |    _    | |   | |   | |    _            !
!             | |   | |   | |   | |   | |   | |   | |   | |   | |           !
!             |_|   |_|   | |   |_|   |_|   |_|   | |   |_|   |_|           !
!                         |_|                     |_|                       !
!                                                                           !
!                    CCC    IIII     SSS      CCC      OOO                  !
!                   C        II     S        C        O   O                 !
!                   C        II      SS      C        O   O                 !
!                   C        II        S     C        O   O                 !
!                    CCC    IIII    SSS       CCC      OOO                  !
!                                                                           !
!                                                            Ver. 05/29/07  !
!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!
!                                                                           !
!                 File Name         : archivo                              !
!                 Assembly Name     : Pinedrops_M                           !
!                 Board Name        : Pinedrops_M                           !
!                 Assembly P/N      : 800-xxxxx-xx Rev xx                   !
!                 Fab               : 28-13729-05  Rev 03                   !
!                 Bom               : 73-18922-05  Rev 05                   !
!                 Schematic         : 92-102973-05 Rev 03                   !
!                 PCA Map           : 61-103367-05 Rev 03                   !
!                 Test Engineer     : Simin Tan                             !
!                 Last Update       : 07/21/18                              !
!                                                                           !
!---------------------------------------------------------------------------!
!                                                                           !
!                 ICT board S/N     :                                       !
!                 CIP #             :                                       !
!                 Fixture Asset Tag : 0143924                               !
!                 Installation Date : 07/21/18                              !
!                 CM                :                                       !
!                                                                           !
!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!


!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!
!         unidades          !
!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!
!Items                      | Installed | Wiring Instructions | Comments    !
!                           | (Y/N)     | File Name           |             !
!---------------------------+-----------+---------------------+-------------!
!Present Switch             |           |                     |             !
!---------------------------+-----------+---------------------+-------------!
!LED Testing                |           |                     |             !
!   SmartFinn               |           |                     |             !
!   Ledcheck                |           |                     |             !
!---------------------------+-----------+---------------------+-------------!
!Other LED Testing          |           |                     |             !
!---------------------------+-----------+---------------------+-------------!
!Clock Divider Board*       |           |                     |             !
!   PECL Clock Divider      |           |                     |             !
!   700MHz CLK Divider      |           |                     |             !
!---------------------------+-----------+---------------------+-------------!
!Termination Resistor       |           |                     |             !
!---------------------------+-----------+---------------------+-------------!
!Pull-up/down Resistor*     |           |                     |             !
!---------------------------+-----------+---------------------+-------------!
!Long Probe for Dual Stage* |           |                     |             !
!---------------------------+-----------+---------------------+-------------!
!Probe Removed*             |           |                     |             !
!---------------------------+-----------+---------------------+-------------!
!Special Probe Style        |           |                     |             !
!   Focal Probe*            |           |                     |             !
!   X Probe*                |           |                     |             !
!---------------------------+-----------+---------------------+-------------!
!Special Probe Type*        |           |                     |             !
!---------------------------+-----------+---------------------+-------------!
!Heat Sink                  |           |                     |             !
!---------------------------+-----------+---------------------+-------------!
!Fan                        |           |                     |             !
!---------------------------+-----------+---------------------+-------------!
!Miscellaneous              |           |                     |             !
!                           |           |                     |             !
!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!
!Reference should be with 1). Node name 5). Probe number 3). PP number


!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!
!                   cambio                     !
!---------------------------------------------------------------------------!
! No. | Actions                                               | Yes or N/A  !
!-----+-------------------------------------------------------+-------------!
! 01  | Provided all header information in testplan.          |             !
!-----+-------------------------------------------------------+-------------!
! 02  | All option flags set up correctly as defined for      |             !
!     | production in testplan.                               |             !
!-----+-------------------------------------------------------+-------------!
! 03  | Programmed IDROM according to PCAMAP.                 |             !
!-----+-------------------------------------------------------+-------------!
! 04  | Verified IDROM programming with function test,        |             !
!     | including 8-bit vs 16-bit.                            |             !
!     | Name of Function Test engineer who helped verify.     |             !
!-----+-------------------------------------------------------+-------------!
! 05  | If no PCAMAP is used, the IDROM digital test should   |             !
!     | execute the ERASE command to write back all address   |             !
!     | locations with a default value to avoid boot up issue |             !
!     | at function test and diag.                            |             !
!-----+-------------------------------------------------------+-------------!
! 06  | Test options, KGB and BOM match with assembly number. |             !
!-----+-------------------------------------------------------+-------------!
! 07  | Updated testplan with devices not tested in section   |             !
!     | "parts not tested".                                   |             !
!-----+-------------------------------------------------------+-------------!
! 08  | Moved board directory to "released" directory.        |             !
!-----+-------------------------------------------------------+-------------!
! 09  | Moved new or custom test libraries to central         |             !
!     | library.                                              |             !
!-----+-------------------------------------------------------+-------------!
! 10  | Assembly options verification.                        |             !
!-----+-------------------------------------------------------+-------------!
! 11  | Plugged all receptacles with probes removed.          |             !
!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!


!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!
!                                  E C O ' S                                !
!---------------------------------------------------------------------------!
!                                                                           !
! Date      ECO #      Status  By  What Changes                             !
! --------  ---------  ------  --  ---------------------------------------- !
! 20180802                     Tan upgrated to 73-19246-05 A0                !
!                                                                           !
!                                                                           !
!                                                                           !
!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!

!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!
!          T E S T M A I N     Revisar          !
!---------------------------------------------------------------------------!
!                                                                           !
! Date      Verified  By  Notes                                             !
! --------  --------  --  ------------------------------------------------- !
! 05/29/07   Yes      DL  Disabled vacuum recycling when running in         !
!                         evaluation mode, a new requirement.               !
!                                                                           !
!                         Updated serial number validation per new document !
!                         number 70106-0000 revision G0. Characters 'I' and !
!                         'O' are now valid to use in location (LLL) and    !
!                         sequential serial ID (SSSS). Location (LLL) is    !
!                         now of base 36, alpha/numeric.                    !
!                                                                           !
! 10/05/06   Yes      DL  Updated with new Cisco logo.                      !
!                                                                           !
!                         Added stop when evalog failed to run.             !
!                                                                           !
! 09/05/06   Yes      DL  Undo "object checking off." This is only done     !
!                         prior to program release.                         !
!                                                                           !
!                         Delete subroutine Tup. Use function looptest      !
!                         instead.                                          !
!                                                                           !
!                         Move TestJet call to after Analog_Tests and       !
!                         remove the "unpowered" after TestJet.             !
!                                                                           !
! 08/09/06   Yes      DL  Turned off object checking as part of Test Time   !
!                         Reduction (TTR).                                  !
!                                                                           !
! 08/29/05   Yes      DL  Changed final report destination from             !
!                         "/dev/rpr"&th$ to btgetenv$("RPR"&th$) for PC     !
!                         compatibility.                                    !
!                                                                           !
! 01/20/05   Yes      DL  Added call to program evalog.                     !
!                                                                           !
! 08/26/04   Yes      DL  Changed default setting for Evaluation_runs to    !
!                         20 per new requirements.                          !
!                                                                           !
! 08/17/04   Yes      DL  Changed codes for Evaluation run data logging.    !
!                                                                           !
! 08/16/04   Yes      DL  Added new checklist item for receptacle plugins.  !
!                                                                           !
!                         Added custom subroutine Check_BD_Present to check !
!                         for board presence prior to testing.              !
!                                                                           !
! 07/08/04   Yes      DL  Added feature to support serial number            !
!                         validation.                                       !
!                                                                           !
! 05/19/04   Yes      DL  Updated sub Regulators and sub CPLDs with         !
!                         parameters for 5.21 and later compatibility.      !
!                                                                           !
! 03/01/04   Yes      DL  Copied Agilent 3070 standard testmain rev 05.30p  !
!                         and migrated custom features from pre 05.30       !
!                         testmain.                                         !
!                                                                           !
!                         Added options to support ICT Aware process        !
!                         (CISCO_ICT_AWARE).                                !
!                                                                           !
!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!


!##############################################################################
!   AGILENT ICT STANDARD TESTMAIN       Revision: "cambio"
!   STANDARD VERSION
!##############################################################################
!   This "main" program sequences execution of testplan subroutines and
!   assumes that the current working directory is already set to the
!   appropriate board directory.
!   This testmain has included the code to support the following optional
!   features:
!        Data Logging for PushButton QSTATS, QSTATS-II and ART
!        Chek-Point (pin tests)
!        Boundary Scan: Interconnect Plus & ScanWorks
!        Agilent Intelligent Yield Enhancement Test (IYET)
!        Agilent Worst Probe Report (WPR)
!        Agilent First Pass Yield (FPY)
!   Once the testplan is working, you may selectively enable
!   any combination of the features by changing the 'flag' variables
!   in the subroutine "Set_Custom_Options".  Use the following command:
!         find  "!   Other"&" parameters"  ! takes you to option settings
!
!   Turn learn on and run the testplan on a known good board.  After the
!   learning run is successfully completed, the testplan is ready for
!   customization, debug and production testing.
!   Analog limits are logged by standard testmain if and only if the
!   learn flag is on.  Limits must be logged once each time they change
!   in order for PushButton Q-STATS or Q-STATS II to produce histograms.
!
!   If flash is to be programmed on this board, the testplan needs to have the
!   locations marked !flash! modified or reviewed.  Please review the flash
!   manual for full explanation. Key elements include:
!
!   full disabling of buses and upstream control lines is required for safety
!   use ID check for digital test subroutine to ensure proper part placement
!   Cycle power if required to three-state upstream devices

! Miscellaneous string variable size declarations:
! EEprom variables
! for ACT2 quack ic programming

un nuevo cambio

dim InvOn$[28], InvOff$[11], O$[128], Retry_Pintest$[168]
dim Cycle_Vacuum$[128], Recycle_Vacuum$[128]
dim Testmain_Revision$[70]
dim Batch$[12], Oper$[25], Testplan$[100], Testrev$[4]
dim Board$[100], Board_Rev$[14], Known_Good$[1]
dim Proc_Step$[5], Log_Path$[200]
dim TSerial1$[11],TSerial2$[11],TPart1$[11],TPart2$[11], FFMsg$[48]
dim Log_Time$(0:23),Months(1:12)
dim X1149Msg$[2048]                                               !x1149

! The following is used in the power-supply setup routine for parallel
! power supplies.  It holds masks for comparison.
dim Psgroup(1:16)
option bit 32     ! Prevents range error when comparing Psgroup with MSB set
dim Act2_Vendor$[7]
dim Act2EprPath$[70]
! IYET
dim IYET_Failing_Tests$(0:2047)[40]
dim IYET_Retest_Failing_Devices$(0:8191)[40]
dim IYET_Top_Retests$(0:8191,2)[40]

  !add retest without send Flexflow !FGU, 1 to 6
SILDir$ =  "F:/.SIL/"
SIL2Dir$ = "F:/.SIL2/"
SIL = True
SIL2 = True



!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!
!                                  N O T E S                                !
!---------------------------------------------------------------------------!
!                                                                           !
! Date      Status  By  Notes                                               !
! --------  ------  --  --------------------------------------------------- !
! mm/dd/yy  ???     ??                                                      !
!                                                                           !
!                                                                           !
!                                                                           !
!=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=!


!       INITIALIZE BREAK AND ERROR TRAPPING

on break recover Break_Trap
on error recover Error_Trap

!       INITIALIZE VARIABLES

call Initializations

if Using_x1149 then                                                        !x1149
  print tab(5);"Initializing connection to x1149 system..."                !x1149
  ABS_Project$ = "Project.absp"                                            !x1149
  ABS_IPAddress$ = "192.168.1.2"                                           !x1149
  call X1149_Initialize_Connection                                         !x1149
end if                                                                     !x1149


!       SET UP FAILURE ACKNOWLEDGMENT
acknowledge all failures

!       MAIN LOOP FOR REPEATEDLY TESTING A BOARD
!          (executed only once if "learning")
Flex_Flow_V:
Wait_For_Start:

!!!!!***********************operadores certificados*************************
  call Checa_operador
!!!!!***********************fin rutina de operadores************************

Pass_Fail_Reported = False
Logging_Started = False
Tests_On_This_Board = 0
!@print | print Place_Board_Prompt$

if Serializing then
  Try_Again:
  call Get_Version    !! Added by flex
  Serial$ = fn Get_Serial_Num$(Serial_Prompt$)
  call Fixture_Set
     !add retest without send Flexflow !FGU,2 to 6
     SIL  = fn ShouldILog(Serial$)
     SIL2 = fn ShouldILog2(Serial$)
  if Flex_Flow then
     call FF_Val(Serial$, Flex_Flow)
     if FL then goto Try_Again
  end if
  Known_Good$ = "n"
  if Serial$ = Known_Good_Board$ then Known_Good$ = "y"
 if StopLine$ = "1" then goto STOPLINED
    call Validation_FF
    if FF_V then goto Try_Again

STOPLINED:

  if Using_AwareTest = True then
    ! remove special characters
    Serial_New$ = fn Remove_Special_Characters$(Serial$)
    Path$ = Serial_Number_Directory$ & Serial_New$ & Serial_Suffix$
    enter Path$,, Err

    !! Added the following code to check for all uppercase or all lowercase
    !! serial numbers.
    if Err then
       Path$ = Serial_Number_Directory$ & upc$(Serial_New$) & Serial_Suffix$
       enter Path$,, Err
       if Err then
          Path$ = Serial_Number_Directory$ & lwc$(Serial_New$) & Serial_Suffix$
          enter Path$,, Err
       end if
    end if

    if Err then
      ! serial number file was not found -- board was not tested on AXI
      if AXI_Tested_Override = False then
         print Not_AXI_Tested$
         goto Wait_For_Start
      else
        ! Add custom code here if serial number is missing and
        ! you do not want to completely skip the PC board test
      end if
    end if
  end if
end if

if Using_Multiple_Versions and Version_Prompting = Per_Board then
  call Get_Version_Label
  if nrun = 1 or Version_Inits_Needed then
    call Do_Version_Inits
  end if
end if

  if Flex_Flow then
       print chr$(27)&"&v2S************* Flex_Flow habilitado ****************"
       else
       print chr$(27)&"&v4S************* Flex_Flow Deshabilitado *************"
       end if
  if not SIL then
        print Green$&" PRIMERA VEZ QUE SE PRUEBA ESTA UNIDAD 1RETRY "
    end if
     if SIL and not SIL2 then
         print Yellow$&"SEGUNDA VEZ QUE SE PRUEBA ESTA UNIDAD 2RETRY "
     end if
       if SIL2 then
          print Red$&"TERCERA VEZ QUE SE PRUEBA ESTA UNIDAD 3RETRY "
       end if

print | print Place_Board_Prompt$
call Check_board
wait for start
execute "title "&Assembly$&" "&Model_Type$

!       RE-TEST AFTER PIN-TEST FAILURE

ChekPoint_Retry:

print using "@,/"
if Serializing then print But$; Serial$
Tests_On_This_Board = Tests_On_This_Board + 1
if Tests_On_This_Board > 1 then print Rep_Test$

!       START LOGGING FOR THIS BOARD

!-030104S
!report is Report_Printer$
!-030104E

!+030104S
if Evaluation then
   if Aware_fail_report then
      report is Report_Printer$; append
   else
      report is Report_Printer$,window;append
   end if
end if

if Print_to_file then
   if Evaluation then
      if Aware_fail_report then
         report is Report_Printer$; append
      else
         report is Report_Printer$,window; append
      end if
   else
      if Aware_fail_report then
         report is Report_Printer$
      else
         report is Report_Printer$,window;append
      end if
   end if
else
   report is Report_Printer$,window;append
end if
!+030104E

if Logging then call Start_Logging
Logging_Started = True   ! Also used as reporting flag

!       ACTIVATE VACUUM IN PREPARATION FOR TEST

if Tests_On_This_Board = 1 then call Counter |  faon
! Warning: Reducing the value for 'faon' from the default value of 1.5
! can potentially cause testhead damage.

print using "@"
call Print_board_testing_msg


!       CHECK FIXTURE CONTACT, THEN
!       LEARN OR TEST (OR RE-TEST) BOARD

unpowered

   print tab(5); chr$(27)&"&v2S Doing discharge for board......"
   wait 5

if (not learning) and Chek_Point_Mode = Pretest then
  if not fn Chek_Point_OK then goto Cleanup
end if
A=msec
call Test_Sections

if boardfailed then
   goto AAAA
end if

call CheckAct2Log

AAAA:

!       IF ANY BOARD FAILED TEST, TRY TO FIX IT BY RUNNING PIN TEST

Cleanup:

if boardfailed and Status <> Failed_In_Preshorts then
  if Tests_On_This_Board = 1 and Chek_Point_Mode = Failures then
    unpowered
    if fn Chek_Point_OK then goto ChekPoint_Retry
  end if
end if

!       REMOVE BOARD FROM TESTHEAD AND GENERATE PASS/FAIL MESSAGE
!       THEN TERMINATE LOGGING (IF ENABLED) AND REPORTING
 auxdisconnect 5

faoff
unpowered  !Added for print failures option to avoid unattended power-on UUT.
Pass_Fail_Reported = True

Eject_Ticket: image 13/

if not boardfailed then
    Passt = 1
    Vuelta = Vuelta + Passt

     if Vuelta > 4 then
       test monitor
     end if
end if

log board end Status

  log out"C:\LogData\"&System$&"_Autotestlog_"&Serial$[1;11]&"_"&datetime$,Err_Temporal
  log out "F:\Logout\ICT_Utilization\"&Serial$[1;11], Err

if boardfailed then

!#############################################################################

             !add retest without send Flexflow !!3 to 6 !!FLEX FGU
!-----------------   1st. retry  -----------------------------------------
  if Flex_Flow then
     if not SIL then
       SN_File$ = SILDir$&"/"&Serial$[1;11]
       assign @Serial_Numbers_File, Error to SN_File$; write    !!JJSR
       assign @Serial_Numbers_File to *                         !!JJSR
       print chr$(27)&"&v7S FAVOR DE PROBAR LA TARJETA NUEVAMENTE 2 RETRY"
      else
!------------------   2nd. retry  -----------------------------------
        if not SIL2 then
           SN_File$ = SIL2Dir$&"/"&Serial$[1;11]
           assign @Serial_Numbers_File, Error to SN_File$; write    !!JJSR
           assign @Serial_Numbers_File to *                         !!JJSR
           print chr$(27)&"&v7S FAVOR DE PROBAR LA TARJETA NUEVAMENTE 3 RETRY"
        end if
      end if
  end if
!#############################################################################

  if  SIL2 and Flex_Flow then  !add retest without send Flexflow !LV,4 to 6
      log out "F:\CiscoData\Files To Transfer\"&System$&"_Autotestlog_"&Serial$[1;11], Err_Temporal
         !##############################  !!FLEX FGU
         !add retest without send Flexflow !LV,5 to 6
         execute "rm "&SILDir$&Serial$[1;11]&"*"
         execute "rm "&SIL2Dir$&Serial$[1;11]&"*"
         print chr$(27)&"&v1S UNIDAD FALLADA EN FF ENVIAR A DIAGNOSTICO"
         !##############################
    end if
     print "...>>> F A I L E D <<<..."
     copy Fail_File$ over "/dev/tty"

 else
         !##### Clean SIL folder ########## !!FLEX FGU ###
         !add retest without send Flexflow !LV,5 to 6
         if SIL then execute "rm "&SILDir$&Serial$[1;11]&"*"
         if SIL2 then execute "rm "&SIL2Dir$&Serial$[1;11]&"*"
         !####### End Clean SIL folder #################

     print "...>>> P A S S E D <<<..."
     copy Pass_File$ over "/dev/tty"

end if

if not boardfailed then
  print Green$&"     **  ";Pass_Msg$;"  **"
  report chr$(27)&"&v2S**  ";Pass_Msg$;"  **"
  report chr$(27)&"&v2SS/N:"&Serial$
  report out
 else
   print Red$&"     **  ";Fail_Msg$;"  **"
   report chr$(27)&"&v4S ##########ICT Fail #######"
   report chr$(27)&"&v4S"&Serial$
   report chr$(27)&"&v4S Operator ID: ";Oper$
   if Status = Failed_Pin_Test then
    print " ** ";Pin_Msg$;" **"
   end if
 report out
end if



if boardfailed then
  if not Using_BtBasic then first pass yield 0, 1 !FPY not Passed and Tested
!@  print "     **  ";Fail_Msg$;"  **"
!@  copy Fail_File$ over "/dev/tty"
  if Status = Failed_Pin_Test then
    print " ** ";Pin_Msg$;" **"
  end if
  if learning then Status = Failed_In_Learn
  if Serializing then report Serial_Nr$ & Serial$
  report using Eject_Ticket
  if Using_Buffered_Reporting then report out
else
  if not Using_BtBasic then first pass yield 1, 1 !FPY Passed and Tested
!@  print "     **  ";Pass_Msg$;"  **"
!@  copy Pass_File$ over "/dev/tty"
  if Using_AwareTest = True then
    enter Path$,, Err  ! check to see if serial number file exists
                       ! Err = 100009 (File Not Found)
    if not Err then    ! Do not create new serial number files
      enter "date +%Y%m%d%H%M |"; Passed_Datetime$
      assign @SNF,Err to Path$; write, append
      if Err then      ! problems writing to serial number file
        print SNF_Error_Msg$  |   print "    ";errm$
        beep
        ! print | print Stop_Msg$
        ! stop
      else
        output @SNF; "passedICT = " & Passed_Datetime$
        assign @SNF to *
      end if
    end if
  end if
end if
!report is *
if Logging then
  log board end Status
!Glog out Log_Path$ & datetime$ & System$ & th$
  log clear
end if

report out "Fail"      !! Send to logfile to File named Fail

report clear

clear failures
Logging_Started = False

!       END PROGRAM IF LEARNING. OTHERWISE RETURN TO MAIN LOOP

if learning then
   learn off
   print | print Learning_Off_Msg$ | print Stop_Msg$
   beep
   stop
end if
B=(msec-A)/1000
!print "                Testime : " &val$(B)
print tab(10),Blck$&"Testime : " &val$(B)

if Using_LogTime then
 if not boardfailed then

  assign @W to "test_time.txt";write,append
  output @W;"S/N:"&Serial$

  output @W;"Pre_short_test_time:",Pre_short_end," sec"
  output @W;"Short_test_time:",Short_end," sec"
  output @W;"Testjet_test_time:",Testjet_end," sec"
  output @W;"Analog_unp_test_time:",Analog_unp_end," sec"
  output @W;"Analog_Cluster_test_time:",Analog_Cluster_end," sec"
  output @W;"Pins_Long_test_time:",Pins_Long_end," sec"
  output @W;"Setup_power_test_time:",Setup_power_end," sec"
  output @W;"Digital_test_time:",Digital_end," sec"
  output @W;"BScan_Interconnect_test_time:",BScan_Interconnect_end," sec"
  output @W;"Bscan_incircuit_test_time:",Bscan_incircuit_end," sec"
  output @W;"Analog_functional_test_time:",Analog_functional_end," sec"
  output @W;"ACT2_Program_test_time:",ACT2_Program_end," sec"
  output @W;"Functional_test_time:",Functional_end," sec"
  output @W;"ScanWorks_Scan_Path_Verify_test_time:",ScanWorks_Scan_Path_Verify_end," sec"
  output @W;"ScanWorks_Pretest_test_time:",ScanWorks_Pretest_end," sec"
  output @W;"Total_test_time:",val$(B)," sec"
  output @W;"!--------------------------------------------"
  assign @W to *

 end if
end if

goto Wait_For_Start

!       END OF MAIN LOOP
!       INTERRUPT HANDLING
! This is the normal entry for Break/Stop detection

Break_Trap:

off break
off error
print "     ";Break_Msg$
unpowered,Err
if Err then print errmlong$
if Logging and Logging_Started then
  log board end Break_Code
!Glog out Log_Path$ & datetime$ & System$ & th$
   log out"C:\LogData\"&System$&"_Autotestlog_"&Serial$[1;11]&"_"&datetime$,Err_Temporal
  log clear
end if
faoff, Err
if Err then print errmlong$


!x1149                                                                  !x1149
if Using_x1149 and X1149_Connected$ = "1" then                          !x1149
  dllcall DLL_Handle, "ReleaseHardware", X1149Result, X1149Msg$         !x1149
  print X1149MsgMsg$                                                    !x1149
  X1149_Connected$ = "0"                                                !x1149
end if                                                                  !x1149
!x1149                                                                  !x1149


goto Abort

! This is the normal entry for errors occurring in Basic statements

Error_Trap:

off error
print errmlong$

!x1149                                                            !x1149
if Using_x1149 and X1149_Connected$ = "1" then                    !x1149
  dllcall DLL_Handle, "ReleaseHardware", X1149Result, X1149Msg$   !x1149
  print X1149Msg$                                                 !x1149
  X1149_Connected$ = "0"                                          !x1149
end if                                                            !x1149
!x1149                                                            !x1149


beep
SaveErrn = errn
unpowered,Err
if Err then print errmlong$

!       IF A BOARD IS PRESENT, FAIL IT
!       THEN TERMINATE LOGGING (IF ENABLED) AND REPORTING

if Logging_Started and not Pass_Fail_Reported then
  fail device
  report Board_Not_Tested$
  print "     **  ";Fail_Msg$;"  **"
  copy Fail_File$ over "/dev/tty"
  if Status = Failed_Pin_Test then
    print " ** ";Pin_Msg$;" **"
  end if
  if Serializing then report Serial_Nr$ & Serial$
  report using Eject_Ticket
  if Using_Buffered_Reporting then report out, Err
 ! report is *, Err
  report clear
end if
if Logging_Started and Logging then
  log using """{@RPT~80|"",80a,""}""" ; errm$(SaveErrn)
  log board end Error_Code, SaveErrn
!Glog out Log_Path$ & datetime$ & System$ & th$
  log clear
end if
!       REMOVE THE BOARD FROM THE TESTHEAD

faoff, Err
if Err then print errmlong$
if learning or Err then goto Abort
on error recover Error_Trap
goto Wait_For_Start

!       ABORT PROGRAM: UNRECOVERABLE ERROR, LEARN ERROR OR STOP KEY

Abort:

off break
off error
probe report off
!report is *, Err
log is *, Err


!x1149                                                            !x1149
if Using_x1149 and X1149_Connected$ = "1" then                    !x1149
  dllcall DLL_Handle, "ReleaseHardware", X1149Result, X1149Msg$   !x1149
  print X1149Msg$                                                 !x1149
  X1149_Connected$ = "0"                                          !x1149
end if                                                            !x1149
!x1149                                                            !x1149


call Disconnect_FXT_Power_Supplies

beep
if (nrun=1) and not Did_First_Run_Inits then
  print No_Init_Warning$
  clear nrun
else
  if Version_Inits_Needed then
    print No_Version_Init_Warning$
    clear nrun
  end if
end if
print "     ";Stop_Msg$
beep
stop
end

!       END OF ERROR TRAPS

!       Test/Learn Sections
!    [ Assumes unpowered mode. ]
! Note concerning LEARN MODE:  some sections are not truly "learned" but are
! run in learn mode for other reasons.  For example, analog tests may be run
! in learn mode in order to log limits information used by Pushbutton QSTATS,
! and preshorts/shorts are run "just in case" -- to avoid bad learns & damage.
! To keep a section from being run in learn mode, place 'if not learning then'
! just before that section and place 'end if' just after it.
!##############################################################################
sub Test_Sections
global PreshortsMsg$, ShortsMsg$, PowerMsg$, DigitalMsg$, AnalogMsg$
global DigitalFuncMsg$, AnalogPoweredMsg$, BScanIncktMsg$, BScanIntconMsg$
global Status, Failed_In_Preshorts, Failed_In_Shorts, Failed_In_Functional
global Failed_In_Digital, Failed_In_Power_Supplies, Failed_In_Analog
global Logging, True, False, Passed, DigitalProgMsg$
global Mode$, Failed_In_BScan
global TestJetMsg$, Failed_In_TestJet
global VectorlessTestMsg$, Failed_In_VectorlessTest
global PolarityMsg$, Failed_In_Polarity_Check
global BScanPShortsMsg$
global ConnectCheckMsg$, Failed_In_ConnectCheck
global VerifyGroundsMsg$, Failed_In_Verify_Grounds
global Failed_In_Flash, FlashProgMsg$, Programming
global AnalogClusterMsg$, Failed_In_Analog_Cluster
global BScanSiNailsMsg$, Failed_In_BScan_SiNails
global CoverExtendMsg$, Failed_In_Cover_Extend
global SW_ScanPathVerifyMsg$, Failed_In_SW_Testing
global SW_DrVerifyMsg$, SW_IrVerifyMsg$
global SW_InterconnectMsg$, SW_MemInterconnectMsg$
global SW_ClusterMsg$, SW_MemBistMsg$
global SW_ProgrammingMsg$, Failed_In_SW_Programming
global SW_FlashMsg$, Failed_In_SW_Flash
global Long_Pin_Msg$, Failed_Long_Pin_Test, IYET_LongPin_Attempts
global PrePoweredMsg$, Failed_In_Pre_Powered
global Red$, Blue$, Yellow$, Green$, Black$, Cyan$

!!**************** test time variables ***********************************
global Using_LogTime
global Pre_short_start,Pre_short_end,Short_start,Short_end
global Testjet_start,Testjet_end,Analog_unp_start,Analog_unp_end
global Pre_Powered_start,Pre_Powered_end,Setup_power_Prog_start
global Setup_power_Prog_end,Analog_functional_start,Analog_functional_end
global Pins_Long_start,Pins_Long_end, ACT2_Program_Status_start, ACT2_Program_Status_end
global TPS53678_Prog_start,TPS53678_Prog_end,Setup_power_start,Setup_power_end
global Digital_start,Digital_end,Bscan_incircuit_start
global Bscan_incircuit_end,Bscan_silicon_nail_start,Bscan_silicon_nail_end
global BScan_Interconnect_start,BScan_Interconnect_end
global Functional_start,Functional_end, Disconnect_Power_start, Disconnect_Power_end
!!**************** test time variables ***********************************

! IYET
global IYET_PinLong_Attempts
global Using_IYET, Sampling, IYET_Preshorts_Attempts, IYET_Shorts_Attempts
global IYET_Analog_Tests_Attempts, IYET_VectorlessTest_Attempts
global IYET_Max_Msg$
global Fpsfailed
global ACT2_Program_Status
global Autofile$
! x1149                                                           !x1149
global X1149TestMsg$, Failed_In_x1149_Testing, ABS_IPAddress$     !x1149
global DLL_Handle, Using_x1149, X1149Msg$, ABS_Project$           !x1149
global X1149_Connected$                                           !x1149
A= msec
! Uncomment the next two lines to setup Fixture Power Supplies
! call Setup_FXT_Power_Supplies (Failed_In_FXT_Power_Supplies, FixturePowerMsg$)
! if Fpsfailed then subexit

Pre_short_start = msec
if (not Using_IYET) or (Using_IYET and IYET_Preshorts_Attempts = 0) then
   call Pre_Shorts (Failed_In_Preshorts, Mode$ & PreshortsMsg$)
else
   if IYET_Preshorts_Attempts > 0 then
       call IYET (PreshortsMsg$, IYET_Preshorts_Attempts)
   else
       print PreshortsMsg$, IYET_Max_Msg$
       beep
       stop
   end if
end if
if boardfailed then subexit
Pre_short_end = (msec-Pre_short_start)/1000

Short_start = msec
if (not Using_IYET) or (Using_IYET and IYET_Shorts_Attempts = 0) then
   call Shorts (Failed_In_Shorts, Mode$ & ShortsMsg$)
else
   if IYET_Shorts_Attempts > 0 then
       call IYET (ShortsMsg$, IYET_Shorts_Attempts)
   else
       print ShortsMsg$, IYET_Max_Msg$
       beep
       stop
   end if
end if
if boardfailed then subexit
Short_end = (msec-Short_start)/1000

Testjet_start = msec
if (not Using_IYET) or (Using_IYET and IYET_VectorlessTest_Attempts = 0) then
   call VectorlessTest (Failed_In_VectorlessTest, Mode$ & VectorlessTestMsg$)
else
   if IYET_VectorlessTest_Attempts > 0 then
       call IYET (VectorlessTestMsg$, IYET_VectorlessTest_Attempts)
   else
       print VectorlessTestMsg$, IYET_Max_Msg$
       beep
       stop
   end if
end if
if boardfailed then subexit
Testjet_end = (msec-Testjet_start)/1000

Analog_unp_start = msec
if Logging or not learning then
   if Using_IYET and not learning then !! and not Sampling
       if IYET_Analog_Tests_Attempts > 0 then
           call IYET (AnalogMsg$, IYET_Analog_Tests_Attempts)
       end if
       if IYET_Analog_Tests_Attempts = 0 then
           call Analog_Tests (Failed_In_Analog, Mode$ & AnalogMsg$)
       end if
       if IYET_Analog_Tests_Attempts < 0 then
           print AnalogMsg$, IYET_Max_Msg$
           beep
           stop
       end if
   else
       call Analog_Tests (Failed_In_Analog, Mode$ & AnalogMsg$)
   end if
   if boardfailed then subexit
end if
Analog_unp_end = (msec-Analog_unp_start)/1000

call Polarity_Check (Failed_In_Polarity_Check, Mode$ & PolarityMsg$)
if boardfailed then subexit

call Connect_Check (Failed_In_ConnectCheck, Mode$ & ConnectCheckMsg$)
if boardfailed then subexit

Analog_Cluster_start = msec
call Analog_Cluster_Tests (Failed_In_Analog_Cluster, Mode$ & AnalogClusterMsg$)
if boardfailed then subexit
Analog_Cluster_end = (msec-Analog_Cluster_start)/1000

! The subroutine, "Verify_Grounds" must be run prior to the "powered" command.
! If the board fails, then DO NOT execute the "powered" command.
call Verify_Grounds (Failed_In_Verify_Grounds, Mode$ & VerifyGroundsMsg$)
if boardfailed then subexit

! Uncomment the next line to turn off Fixture Power Supplies
! call Disconnect_FXT_Power_Supplies

!prepowered

!call Analog_Prepowered_Tests (Failed_In_Pre_Powered, Mode$ & PrePoweredMsg$)
!if boardfailed then subexit

!call Long_Pin_Tests (Failed_Long_Pin_Test, Mode$ & Long_Pin_Msg$)
!if boardfailed then subexit

Pins_Long_start = msec
if Using_IYET then
 call IYET (Long_Pin_Msg$, IYET_PinLong_Attempts)
else
 call Long_Pin_Tests (Failed_Long_Pin_Test, Mode$ & Long_Pin_Msg$)
end if
if boardfailed then subexit
Pins_Long_end = (msec-Pins_Long_start)/1000

powered

! Uncomment the next two lines to setup Fixture Power Supplies
! call Setup_FXT_Power_Supplies (Failed_In_FXT_Power_Supplies, FixturePowerMsg$)
! if Fpsfailed then subexit

! Uncomment the next two lines to setup the Fixture Power Supplies that power the CET card.
! call Setup_CET_FXT_Power_Supplies (Failed_In_CET_FXT_Power_Supplies, CET_FixturePowerMsg$)
! if Fpsfailed then subexit

Setup_power_start = msec
call Setup_Power_Supplies (Failed_In_Power_Supplies, PowerMsg$)
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if
Setup_power_end = (msec-Setup_power_start)/1000

Digital_start = msec
call Digital_Tests (Failed_In_Digital, Mode$ & DigitalMsg$)
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if
Digital_end = (msec-Digital_start)/1000

wait 8   !for digital test reset
BScan_Interconnect_start = msec
call BScan_Interconnect_Tests (Failed_In_BScan, Mode$ & BScanIntconMsg$)
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if
BScan_Interconnect_end = (msec-BScan_Interconnect_start)/1000

Bscan_incircuit_start = msec
call BScan_Incircuit_Tests (Failed_In_BScan, Mode$ & BScanIncktMsg$)
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if
Bscan_incircuit_end = (msec-Bscan_incircuit_start)/1000

Analog_functional_start = msec
call Analog_Functional_Tests (Failed_In_Functional, Mode$ & AnalogPoweredMsg$)
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if
Analog_functional_end = (msec-Analog_functional_start)/1000

print Serial$
ACT2_Program_Status_start = msec
ACT2_Program_Status =  fnCheckACT2Programed(Serial$)
if ACT2_Program_Status =0 then print "ACT2 normal start normal program"
if ACT2_Program_Status =1 then print "ACT2 have programmed ,ICT skiped"
if ACT2_Program_Status =2 then
   print "Please Manual check the ACT2 stauts before the next action !"
   wait 2
  stop
end if
ACT2_Program_Status_end = (msec-ACT2_Program_Status_start)/1000

if ACT2_Program_Status <>0 and ACT2_Program_Status <>1 and  ACT2_Program_Status <>2   then
   print "Unknown  Error occured ,please double check it before continue it !"
   wait 2
  fail device
  log "{@RPT| ACT2 PROGRAMMING FAIL ";"}"
  if boardfailed then subexit
 !stop
end if

if ACT2_Program_Status =0 then
Functional_start = msec
   call Functional_Tests (Failed_In_Functional, Mode$ & DigitalFuncMsg$)
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
   end if
end if
Functional_end = (msec-Functional_start)/1000

if ACT2_Program_Status =1 then print "ACT2 have programmed ,ICT skiped "

ScanWorks_Scan_Path_Verify_start = msec
call ScanWorks_Scan_Path_Verify_Tests (Failed_In_SW_Testing, Mode$ & SW_ScanPathVerifyMsg$)
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if
ScanWorks_Scan_Path_Verify_end = (msec-ScanWorks_Scan_Path_Verify_start)/1000

ScanWorks_Pretest_strart = msec
call ScanWorks_Pretest
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if
ScanWorks_Pretest_end = (msec-ScanWorks_Pretest_strart)/1000


!call BScan_Powered_Shorts_Tests (Failed_In_Shorts, Mode$ & BScanPShortsMsg$)
! if boardfailed then
!   call Disconnect_Power_On_Board
!   subexit
! end if


call ScanWorks_Interconnect_Tests (Failed_In_SW_Testing, Mode$ & SW_InterconnectMsg$)
if boardfailed then
!  call Disconnect_Power_On_Board
!  subexit
end if

call BScan_Silicon_Nails_Tests (Failed_In_BScan_SiNails, Mode$ & BScanSiNailsMsg$)
if boardfailed then
  call Disconnect_Power_On_Board
  subexit
end if

! If you are using Boundary-Scan and you want to cycle power,
! then uncomment the following call and the if-then-else statements.
! call Reset_Board

call ScanWorks_Mem_Interconnect_Tests (Failed_In_SW_Testing, Mode$ & SW_MemInterconnectMsg$)
if boardfailed then
!  call Disconnect_Power_On_Board
!  subexit
end if

call ScanWorks_Cluster_Tests (Failed_In_SW_Testing, Mode$ & SW_ClusterMsg$)
if boardfailed then
!  call Disconnect_Power_On_Board
!  subexit
end if

call ScanWorks_Mem_BIST (Failed_In_SW_Testing, Mode$ & SW_MemBistMsg$)
if boardfailed then
!  call Disconnect_Power_On_Board
!  subexit
end if

X1149:

!x1149                                                                     !x1149
if Using_x1149 then                                                        !x1149

dps|auxdisconnect 5|wait 3

call Setup_Power_Supplies_x1149_Setup (Failed_In_Power_Supplies, PowerMsg$)
                                                                           !x1149
call X1149_BScan_Tests (Failed_In_x1149_Testing, Mode$ & X1149TestMsg$)    !x1149
                                                                           !x1149
                                                                           !x1149
end if !(Using_x1149)                                                      !x1149
!x1149                                                                     !x1149

if Programming then
  if learning then subexit

  !----------------------------------------------------------------------------
  ! Only add the following powersupply setup if it is necessary to cycle power.
  ! Perhaps to get FPGAs or other ASICs to a three-state condition.
  !
  !    !flash! unpowered  ! Only if volatile logic exists upstream
  !
  !    !flash!  put any required gprelays here
  !
  !    !flash!  powered    ! if unpowered above, also use the following only if
  !                        ! digital devices aren't interferring
  !    ! call Setup_Power_Supplies (Failed_In_Power_Supplies, PowerMsg$)
  !    ! if boardfailed then
  !    !    call Disconnect_Power_On_Board
  !    !    subexit
  !    ! end if
  !----------------------------------------------------------------------------
  ! Add the device name to be tested in the call to the Program_Flash
  ! subroutine. If multiple devices are installed, duplicate the call line for
  ! each device.  Pass an empty string as the Message$ parameter to supress
  ! printing messages for devices 2 through N.
  !----------------------------------------------------------------------------

  ! call Program_Flash ("", Failed_In_Flash, FlashProgMsg$)
  if boardfailed then
!    call Disconnect_Power_On_Board
!    subexit
    Custom_failed = 1
    clear failures
  end if

  call ScanWorks_Device_Programming (Failed_In_SW_Programming, SW_ProgrammingMsg$)
  if boardfailed then
    call Disconnect_Power_On_Board
    subexit
  end if

  call ScanWorks_Flash_Programming (Failed_In_SW_Flash, SW_FlashMsg$)
  if boardfailed then
    call Disconnect_Power_On_Board
    subexit
  end if
end if

! Uncomment the next line to turn off Fixture Power Supplies
call Disconnect_Power_On_Board

Status = Passed
subend

!********* add retest without send Flexflow !6 to 6 ************************
!############################   1st retry  ###################################

def fn ShouldILog(SN$)
global SILDir$
global SIL_status,True, False
SN_File$  = SILDir$&"/"&SN$
   assign @Serial_Numbers_File, Error  to SN_File$ ;read
if Error then

    SIL_status = False
    return False
 else
     SIL_status = True
    return True
end if
fnend

!############################   2nd retry  ###################################

def fn ShouldILog2(SN$)
global SIL2Dir$       !!JJSR
global SIL2_status,True, False
SN2_File$ = SIL2Dir$&"/"&SN$       !! JJSR
   assign @Serial_Numbers_File, Error2 to SN2_File$;read      !!JJSR

if Error2  then
    SIL2_status = False
    return False
 else
     SIL2_status = True
    return True
 end if

fnend

!##############################

!       Pin Test Subroutines

!##############################################################################
def fn Chek_Point_OK
! This is the subroutine for forcing the testing of pin contacts.
! If this routine is called before Test_sections (Chek_Point_Mode = Pretest),
! then the internal status will be set to Passed or Failed_Pin_Test.
! If this routine is called after test (Chek_Point_Mode = Failures), then the
! internal status is modified only if failures occur.
!
! The meaning of the function is slightly different when it is called before
! test versus after test.  If called before test, the function returns True
! if, no matter how many times it was cycled, pin test did finally pass.
! If called after test, the function returns True if pin test failed but
! passed after retry.
!
! Note: fn Pinsfailed is external to testmain.
!
global Pin_Msg$, Passed, Chek_Point_Msg$
global Retry_PinTest$, Recycle_Vacuum$, Status, True, False
global Cycle_Vacuum$, Failed_Pin_Test, Max_Times_To_Fix_Contact
global Logging, Serial$, Known_Good$, Chek_Point_Mode, Pretest, Failures

if learning then return (False)
Attempts = 0
loop
  Contact_Passed = not fn Pinsfailed (Chek_Point_Msg$)
  if not Contact_Passed then
    Status = Failed_Pin_Test
  else
    if Chek_Point_Mode = Pretest then Status = Passed
  end if
  Attempts = Attempts + 1
  exit if Contact_Passed or (Attempts > Max_Times_To_Fix_Contact)
  print Pin_Msg$
    faoff 2
    call Counter |  faon
    faoff 2
    call Counter |  faon
! Warning: Reducing the value for 'faon' from the default value of 1.5
! can potentially cause testhead damage.
    unpowered
!@end if
  if Chek_Point_Mode = Pretest then
    clear failures
    report out
    report clear
  end if
end loop
if Chek_Point_Mode = Failures then
  if Contact_Passed and Attempts > 1 then
    if Logging then
      log clear for retest
      log board end Failed_Pin_Test
    end if
    clear failures
    report clear
  end if
  return (Contact_Passed and Attempts > 1)
else
  return (Contact_Passed)
end if
fnend

!       Reset_Board Subroutine

!##############################################################################
sub Reset_Board
   !---------------------------------------------------------------------------
   ! This 'pause' section is placed here to remind the test programmer
   ! that some powered tests may depend upon the TCK/TMS signals of
   ! boundary scan chains/devices being held in a stable state.
   ! When the testplan is run, the tests are properly sequenced
   ! to assure that the disabled state is set; however, board level
   ! circuitry may interfere with the persistence of the disabled state.
   ! You may need to take additional measures; for example, you may
   ! place your own pullup/down resistor in the fixture to assure a
   ! stable TMS and/or TCK, or utilize a GP relay to disable some TCK
   ! oscillator, etc.
   ! For further explanation, see the Boundary-Scan Manual for the
   ! section titled 'Maintaining Persistence of Boundary-Scan Disables'.
   !
   !---------------------------------------------------------------------------
   ! When Boundary-Scan tests are complete, you may need to produce
   ! a hard reset on the board-under-test to bring the ICs back into
   ! operational mode.  One way of doing this is to cycle power to the
   ! board using the following call:

   call Cycle_Power_On_Board ! Cycle Power to reset digital state of board
   ! call ScanWorks_Pretest    ! Configure volatile devices, if needed

   ! Power cycling is time consuming and may not be necessary.  Some boards
   ! may not need any resetting.  Others may have a digital reset node
   ! you can toggle with a digital test to reset the board.
   !
   ! When you have evaluated the needs of this board and modified this
   ! section, remove the pause and these comments.  You should take care
   ! to document the action you have taken for future reference.
   !---------------------------------------------------------------------------
subend

!       Data Logging Subroutines

!##############################################################################
sub Start_Logging
global Analog_Sample_Rate, QSTATS_Mode, Histo, Board$, Tests_On_This_Board
global Sampling, True, False
global Proc_Step$, Batch$, Oper$, Board_Rev$, Testplan$
global Testrev$, Known_Good$, Serial$, Version_Label$
global FixID$, Act2EprPath$
global Fix_Type$, Model_Type$ , System$, Rfid$, Serial_golden$

TSerial1$ = Serialnumber1$
TSerial2$ = Serialnumber2$
TPart1$ = Partnumber1$
TPart2$ = Partnumber2$

Act2EprPath$ = "F:\FRU_data\73-18922-XX"
Sampling = False

if learning then
  log level is all
else
  if rnd < Analog_Sample_Rate * (QSTATS_Mode = Histo) then
    log level is all  !log level is analog without nhls, pin  !changed by tool
    Sampling = True
  else
    log level is all  !log level is indictments without nhl  !changed by tool
  end if
end if
print "Log level: ";lli$;";  Report level: ";rli$;";  Board type: ";Board$
PS$ = Proc_Step$
!Oper$ = Oper$ & "F"& FixID$   !!   Agregar CMRC Fixture ID
if Tests_On_This_Board = 1 then
  log board Board$, PS$, Batch$, Oper$, Board_Rev$, Testplan$, Testrev$, "", "",Rfid$
end if
log board start Serial$, Known_Good$
log "{@PMID|"&Fix_Type$&"}"
log "{@Name|"&Model_Type$&"}"

if Serial_golden$ = "unidad golden" then
log "{@Golden|"&Serial_golden$&"}"
end if

print
subend

!##############################################################################
def fn Get_Serial_Num$(Prompt$)
global Bad_Serial_Image$, Default_Serial_Number$
global Serial_Length, Using_BtBasic
global Black$, Serial_golden$, Cyan$

Denew:
Ciscobar:
Serial_golden$ = ""
print |print
print Black$&"PORFAVOR ESCANEA EL S/N DE LA TARJETA"
Escaneo_start=msec
input OEMSerial$
OEMSerial$ = trim$(upc$(OEMSerial$))



if OEMSerial$ = "GOLDEN" then
print using "@"
Serial_golden$ = "unidad golden"
print tab(24),Black$&"TARJETA EN MODO GOLDEN"
print tab(15),Black$&"ESCANEA EL S/N PARA PROBARLA EN MODO GOLDEN"
input OEMSerial$
OEMSerial$ = trim$(upc$(OEMSerial$))
end if

Escaneo_end=(msec-Escaneo_start)/1000

if Escaneo_end > 5 and Serial_golden$ <> "unidad golden" then
   print ""
   print Black$&"DEMASIADO TIEMPO PONIENDO EL SERIAL, USA EL ESCANER"
   print Cyan$&"TIEMPO:";Escaneo_end,"sec"
   print""
   Escaneo_end = 0
   goto Denew
end if


if OEMSerial$[1;3] <> "FLM" or len(OEMSerial$) <> Serial_Length  then
   print Red_reset$&"NUMERO DE SERIE NO VALIDO, VERIFICA Y ESCANEA DE NUEVO"
   goto Ciscobar
end if

OEMSerial$ = trim$(upc$(OEMSerial$))
Ident$=OEMSerial$
return (Ident$)
fnend
!##############################################################################
!  If the Board name contains any invalid characters, stop processing.
sub Verify_Board_Names
global Stop_Msg$, Bad_Board_Name$, Board$
dim Last_Board$[100]

Found_Bad = 0
if fn IllegalChars_In_Board_Name(Board$) then
  Found_Bad = 1
  print Bad_Board_Name$  |   print "    ";Board$
end if
if Found_Bad then
  print | print Stop_Msg$
  beep
  stop
end if
subend

!##############################################################################
! Check to see if the Board name contains any invalid characters, now only
! check spaces.  Return 1 if yes, and 0 if no.
def fn IllegalChars_In_Board_Name (Board$)
global True, False

if len (Board$) > 0 and pos (Board$, " ") > 0  then
  return True
else
  return False
end if
fnend

!##############################################################################
sub Create_Log_Queue
global Log_Path$, Directory_Exists, Queue_Error_Msg$, Stop_Msg$

create dir Log_Path$, Err
Err = Err and (Err <> Directory_Exists)
if Err then
  print Queue_Error_Msg$  |   print "    ";errm$
  print | print Stop_Msg$
  beep
  stop
end if
subend

!##############################################################################
sub Setup_Logging
global Serial$, Default_Serial_Number$, Testplan$, Batch$
global Known_Good_Board$, Using_ART, Proc_Step$, Oper_Id_Prompt$
global Board$, Oper$, Known_Good_Prompt$
global Serializing, Using_BtBasic

randomize
Proc_Step$             = "btest"
Batch$                 = datetime$ ! Set to a unique identifier so that Q-STATS II can
                                   ! calculate interboard handling and system idle times
Testplan$              = Board$
Default_Serial_Number$ = "default_SN" & th$
Serial$                = Default_Serial_Number$
Known_Good_Board$      = ""
Oper$                  = ""
!@if Using_ART then
!@  if Using_BtBasic then
!@    print using """"&Oper_Id_Prompt$&""",#"
!@    input "",Oper$
!@  else
!@    input prompt Oper_Id_Prompt$; Oper$
!@  end if
!@end if
!if Serializing then Known_Good_Board$ = fn Get_Serial_Num$(Known_Good_Prompt$)
subend

!       Initialization Subroutines

!##############################################################################
sub Initializations
global Logging, Using_Buffered_Reporting, Report_Printer$, Using_ART
global Serializing, Logging_Started, First_Run$, Testmain_Revision$
global Did_First_Run_Inits, QSTATS_Mode
global True, False, Off, No_Histo, Histo, Pretest, Failures
global Version_Inits_Needed, Using_Multiple_Versions
global Per_Run, Per_Board, Version_Prompting
global Using_AwareTest
global Act2_log
global Act2_ch1, Act2_ch2,Act2_ch3
global Red$, Blue$, Yellow$, Green$, Black$, Cyan$

global Using_IYET, Using_WPR
global Fpsfailed
global Print_to_file
global Aware_fail_report

global Using_LogTime

Testmain_Revision$="i3070 09.10p WN(full)"
True = 1
False = 0
Off = 0
No_Histo = 1
Histo = 2
Pretest = 1
Failures = 2
Per_Run = 1
Per_Board = 2
Act2_log = 0
Act2_ch1 = 0
Act2_ch2 = 0
Act2_ch3 = 0
Version_Inits_Needed = False
!***************************** add Flex ***************************************!

!******************************** add Flex ************************************!

Fpsfailed = 0
call Set_Custom_Options
call Initialize_Board_Constants ! external to testmain
call Initialize_Constants
call Verify_Board_Names
Logging_Started = False
Logging = (QSTATS_Mode <> Off) or Using_ART
if Using_ART then Serializing = True
if Using_AwareTest then Serializing = True

! call Get_Board_Revision        ! to interactively set Board_Rev$

call Print_Startup_Message       ! prints out many variables' values
acknowledge all failures
learn capacitance off
if Using_Buffered_Reporting then
  buffered reporting on
else
  buffered reporting off
end if
report is Report_Printer$
printer is *
if Logging then
  call Setup_Logging
  call Create_Log_Queue
else
  log level is all  !log level is non  !changed by tool
end if
if Using_ART then
  report level is all
else
  report level is report
end if
if nrun = 1 then
  print First_Run$
  load board

!'object checking on/off' statement goes here. Default is 'on'
  object checking on
end if
if Using_Multiple_Versions and Version_Prompting = Per_Run then
  call Get_Version_Label
end if
if nrun = 1 or Version_Inits_Needed then
  call Do_Version_Inits
  Did_First_Run_Inits=True
end if

! WPR
!if Using_WPR then probe report on

! IYET
if Using_IYET then call IYET_Initialize

Using_LogTime = False

subend

!##############################################################################
sub Print_Startup_Message
global Board$, Board_Rev$, Using_ART, QSTATS_Mode, Histo
global Analog_Sample_Rate, Chek_Point_Mode, Failures
global Report_Printer$, Using_Buffered_Reporting, Testmain_Revision$
global Serializing, Serial_Length
! IYET
global Using_IYET, IYET_Report_On

! x1149                                                           !x1149
global Using_x1149                                                !x1149

print using "@,2/"
print "BOARD TYPE"
print "  Name:     ";Board$
print "  Revision: ";Board_Rev$
print "AGILENT ICT TESTMAIN"
print "  Report Printer: ";Report_Printer$
print "  Revision:       ";Testmain_Revision$
!   Build list of options to be printed
!     O1$ is first line, O2$ is second line
O1$ =  "  Options: "
if Using_ART then O1$=O1$&" PR+"
if QSTATS_Mode then O1$=O1$&" QSTATS"
if Chek_Point_Mode then
  O1$=O1$&" Chek-Point"
  if Chek_Point_Mode = Failures then
    O1$=O1$&"-Failures"
  else
    O1$=O1$&"-Pretest"
  end if
end if
if (O1$="  Options: ") then
  O2$=O1$
else
  print 10$
  O2$= "           "
end if
if Serializing then O2$=O2$&" Serializing("&val$(Serial_Length)&")"
if learning then O2$=O2$&" LEARNING"
if Using_Buffered_Reporting then O2$=O2$&" Buffered-Reporting"
if QSTATS_Mode = Histo then
  O2$=O2$&" Histograms("&val$(Analog_Sample_Rate)&")"
end if
if not (O2$ = "           ") then print O2$
! IYET
O3$="           "
if Using_IYET then
  O3$=O3$&" Intelligent Yield Enhancement Test"
  if IYET_Report_On then O3$=O3$&"-Report"
end if
print O3$
print using "2/"
subend

!##############################################################################
sub Get_Board_Revision
global Board_Rev$, Board_Rev_Prompt$
global Using_BtBasic

if Board_Rev$ = "" then
  if Using_BtBasic then
    print using """" & Board_Rev_Prompt$ & """,#"
    input "",Board_Rev$
  else
    input prompt Board_Rev_Prompt$; Board_Rev$
  end if
end if
subend

!##############################################################################
sub Do_Version_Inits
global Version_Inits_Needed, Chek_Point_Mode, True, False, Off, Logging

unpowered
faoff
call Characterize
if Chek_Point_Mode <> Off then   ! preload pins into testhead memory
  Log_Level_Reset = False
  if lli$ = "all" then
    if FirstPass = 1 then ! Bill ! 1's pass board setting
      log level is all
    else
      log level is none        ! turn off digital dataloggin  !changed by tool
    end if
    Log_Level_Reset = True       ! for 'ignore all failures'
  end if
!     log level is all  !turn off digital dataloggin !changed by tool
!     Log_Level_Reset = True       ! for 'ignore all failures'
!     end if
  ignore all failures
  Err = fn Pinsfailed ("")       ! external to testmain
  acknowledge all failures
  if Log_Level_Reset = True then log level is all  ! reset datalogging
end if
Version_Inits_Needed = False
subend

!##############################################################################
sub Get_Version_Label
global Version_Label$, Version_Prompt$, True, False
global Version_Inits_Needed, Using_BtBasic

Old_Version$ = bvi$
Version_Inits_Needed = True
loop
  Version_Label$ = ""
  if Using_BtBasic then
    print using """" & Version_Prompt$ & """,#"
    input "", Version_Label$
  else
    input prompt Version_Prompt$; Version_Label$
  end if
  if Version_Label$ = "" or Version_Label$ = "*" then
    board version is *, Err
  else
    board version is Version_Label$, Err
  end if
  exit if not Err
  print errmlong$
end loop
if bvi$ = Old_Version$ then
  Version_Inits_Needed = False
end if
subend

!##############################################################################


def fn Replace_All_Chars$(String$, Char$)
To_Return$ = ""

String_Loop:

String_Loc = pos(String$, Char$)
if String_Loc = 0 then
  To_Return_New$ = To_Return$ & String$
else
  To_Return_New$ = To_Return$ & String$[1;String_Loc - 1] & fn Replace_Character$(Char$)
  String$ = String$[String_Loc + 1]
end if
To_Return$ = To_Return_New$
if String_Loc <> 0 then goto String_Loop
return(To_Return$)
fnend

def fn Remove_Special_Characters$(String$)
! used only with AwareTest.  Replaces all characters that cannot be
! used in an NT filename with their ASCII equivalent.

  To_Replace$ = fn Replace_All_Chars$(String$, "%")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, "|")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, "\")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, "/")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, "<")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, ">")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, "*")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, "?")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, ":")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, " ")
  To_Replace$ = fn Replace_All_Chars$(To_Replace$, """")
  return(To_Replace$)
fnend

!##############################################################################
sub Initialize_Constants
global PreshortsMsg$, ShortsMsg$, PowerMsg$, DigitalMsg$, AnalogMsg$
global DigitalFuncMsg$, AnalogPoweredMsg$, O$
global Break_Detected, Mode$, Board_Not_Tested$
global True, False, InvOn$, InvOff$, First_Run$, Board_Rev_Prompt$
global Pass_Msg$, Fail_Msg$, Pass_File$, Fail_File$, Stop_Msg$, Break_Msg$
global No_Init_Warning$, Rep_Test$, Place_Board_Prompt$, Learning_Off_Msg$
global BT_Passed$, BT_SR_Fail$, BT_CRC_Fail$, BT_Notest$, BT_Indeter$
global BT_Interm$, BT_Incons$, BT_Open$, BT_NResults$
global Confirming$, Confirm_Failed$
global Failed_In_Learn, Failed_Pin_Test, Failed_In_Preshorts, Failed_In_Shorts
global Failed_In_Analog, Failed_In_Power_Supplies, Failed_In_Digital
global Failed_In_Functional, Failed_In_BScan, Passed, Failed
global Directory_Exists, Log_Path$, System$, Queue_Error_Msg$, Board$
global Break_Code, Error_Code, Using_BtBasic
global But$, Serial_Prompt$, Bad_Serial_Image$, Oper_Id_Prompt$
global Known_Good_Prompt$, Serial_Nr$
global Retry_PinTest$, Cycle_Vacuum$, Recycle_Vacuum$
global Pin_Msg$, Max_Times_To_Fix_Contact
global BScanIntconMsg$, BScanIncktMsg$, Chek_Point_Msg$, Chek_Point_Msg2$
global VectorlessTestMsg$, Failed_In_VectorlessTest
global PolarityMsg$, Failed_In_Polarity_Check
global BScanPShortsMsg$, No_Version_Init_Warning$
global Version_Label$, Version_Prompt$
global ConnectCheckMsg$, Failed_In_ConnectCheck
global Failed_In_Flash, FlashProgMsg$
global Serial_Number_Directory$, Not_AXI_Tested$, Serial_Suffix$
global AnalogClusterMsg$, Failed_In_Analog_Cluster
global PrePoweredMsg$, Failed_In_Pre_Powered
global BScanSiNailsMsg$, Failed_In_BScan_SiNails
global CoverExtendMsg$, Failed_In_Cover_Extend
global SW_ScanPathVerifyMsg$, Failed_In_SW_Testing
global SW_DrVerifyMsg$, SW_IrVerifyMsg$
global SW_InterconnectMsg$, SW_MemInterconnectMsg$
global SW_ClusterMsg$, SW_MemBistMsg$
global SW_ProgrammingMsg$, Failed_In_SW_Programming
global SW_FlashMsg$, Failed_In_SW_Flash
global VerifyGroundsMsg$, Failed_In_Verify_Grounds
global Bad_Board_Name$
global Long_Pin_Msg$, Failed_Long_Pin_Test
global FixturePowerMsg$, Failed_In_FXT_Power_Supplies
global CET_FixturePowerMsg$, Failed_In_CET_FXT_Power_Supplies
global Msg1$, Msg2$, Msg_A$, Testt$
! x1149                                                           !x1149
global X1149TestMsg$, Failed_In_x1149_Testing                     !x1149
global IYET_PinLong_Attempts

Using_BtBasic = True
if localizable then Using_BtBasic = False

if Using_BtBasic then
  InvOn$                 = chr$(27)&"&dB"&chr$(7)  ! chr$(7) rings bell
  InvOff$                = chr$(27)&"&d@"
else
  InvOn$                 = "<FONT COLOR=blue SIZE=+2><B>"
  InvOff$                = "</B></FONT>"
end if



def fn Replace_Character$(Char$)
  Val = num(Char$)
  if Val < 9 then
    String$ = "%00" & val$(Val)
  else
    if Val < 99 then
      String$ = "%0" & val$(Val)
    else
      String$ = "%" & val$(Val)
    end if
  end if
  return(String$)
fnend


Break_Detected           = False
Passed                   = 0
Failed                   = 1
Failed_Pin_Test          = 2
Failed_Long_Pin_Test     = 22
Failed_In_Learn          = 3
Failed_In_Shorts         = 4
Failed_In_Analog         = 6
Failed_In_Power_Supplies = 7
Failed_In_Digital        = 8
Failed_In_Functional     = 9
Failed_In_Preshorts      = 10
! Status codes 11, 12 reserved for use by EFS
Failed_In_BScan          = 8      ! Equate to Failed_In_Digital
Failed_In_VectorlessTest = 14
Failed_In_Polarity_Check = 15
Failed_In_ConnectCheck   = 16
Failed_In_Analog_Cluster = 17
Failed_In_Flash          = 18
Failed_In_BScan_SiNails  = 19
Failed_In_SW_Testing     = 8      ! Equate to Failed_In_Digital
Failed_In_SW_Programming = 20
Failed_In_SW_Flash       = 21
Failed_In_Verify_Grounds = 22
Failed_In_Cover_Extend   = 23
Failed_In_Pre_Powered    = 24
Failed_In_FXT_Power_Supplies = 25
Failed_In_CET_FXT_Power_Supplies = 26
Failed_In_x1149_Testing  = 27                                     !x1149
Error_Code               = 80
Break_Code               = 82
Directory_Exists         = 100312
Log_Path$         = btgetenv$("AGILENT3070_ROOT")
if Log_Path$      = "" then  Log_Path$ = btgetenv$("I3070_ICT_ROOT")
Log_Path$         = Log_Path$  &"/qm/logdata/testerq/"&Board$&"/"
enter "uname -n |";System$              ! gets hostname (without domain)
System$                  = lwc$(System$)
Max_Times_To_Fix_Contact = 4            ! MUST BE >= 1
Pin_Msg$                 = "FIXTURE CONTACT PROBLEM"
O$                       = InvOn$&"Press YES"&InvOff$
O$                       = O$&" to retry Pins Test, "&InvOn$&"NO"&InvOff$
Retry_PinTest$           = O$&" to test a new board."
O$                       = InvOn$&"Press YES"&InvOff$&" to cycle vacuum, "
Cycle_Vacuum$            = O$&InvOn$&"NO"&InvOff$&" Otherwise."
O$                       = InvOn$&"Press YES"&InvOff$
Recycle_Vacuum$          = O$&" to turn vacuum on and continue testing."
Queue_Error_Msg$         = "Cannot create directory to queue up log data.  Error is:"
But$                     = "Board Under Test: "
Serial_Prompt$           = InvOn$&"Enter"&InvOff$&" Board Identifier: "
O$                       = "/,""Identifier has wrong length ("",dd,""), must be "
Bad_Serial_Image$        = O$&""",dd,""."",/"
Oper_Id_Prompt$          = InvOn$&"Enter"&InvOff$&" Operator Identifier: "
Known_Good_Prompt$       = InvOn$&"Enter"&InvOff$&" Verification Board Identifier: "
Rep_Test$                = "Repeating test of this board!"
First_Run$               = "Please stand by -- doing first-run initializations"
No_Init_Warning$         = "** WARNING: FIRST RUN INITIALIZATIONS NOT COMPLETED --"
No_Init_Warning$         = No_Init_Warning$ & " CLEARING NRUN **"
O$                       = "** WARNING: VERSION CHANGE INITIALIZATIONS NOT"
No_Version_Init_Warning$ = O$ & " COMPLETED -- CLEARING NRUN **"
Pass_File$               = btgetenv$("AGILENT3070_ROOT")
Fail_File$               = btgetenv$("AGILENT3070_ROOT")
if Pass_File$ = "" then Pass_File$ = btgetenv$("I3070_ICT_ROOT")
if Fail_File$ = "" then Fail_File$ = btgetenv$("I3070_ICT_ROOT")
Pass_File$               = Pass_File$ & "/util/pass"
Fail_File$               = Fail_File$ & "/util/fail"
Board_Not_Tested$        = "Board not tested."
Pass_Msg$                = "P A S S E D"
Fail_Msg$                = "F A I L E D"
Stop_Msg$                = "P R O G R A M   S T O P P E D"
Break_Msg$               = "Break/Stop detected."
Place_Board_Prompt$      = "Place board on fixture and "&InvOn$&"press START"
Board_Rev_Prompt$        = InvOn$&"Enter"&InvOff$&" Board Revision: "
Confirming$              = "Confirming diagnosis..."
Confirm_Failed$          = "Confirm failed; restarting at node """
Learning_Off_Msg$        = "Learning turned off"
if learning then
  Mode$                  = "Learning "
else
  Mode$                  = "Testing "
end if
Long_Pin_Msg$            = "Long Pin Contact"
PreshortsMsg$            = "Preshorts"
ShortsMsg$               = "Shorts"
PowerMsg$                = "Setting Up Power Supplies"
DigitalMsg$              = "Digital Incircuit"
AnalogMsg$               = "Analog Unpowered"
AnalogClusterMsg$        = "Analog Cluster"
VectorlessTestMsg$       = "Vectorless Test"
PolarityMsg$             = "Polarity Check"
ConnectCheckMsg$         = "Connect Check"
DigitalFuncMsg$          = "Digital Functional"
AnalogPoweredMsg$        = "Analog Powered and Mixed"
BScanIntconMsg$          = "Boundary Scan Interconnect"
BScanIncktMsg$           = "Boundary Scan Incircuit"
BScanPShortsMsg$         = "Boundary Scan Powered Shorts"
BScanSiNailsMsg$         = "Boundary Scan Silicon Nails"
CoverExtendMsg$          = "Cover-Extend"
PrePoweredMsg$           = "Pre Powered Tests"
FlashProgMsg$            = "Programming Flash"
X1149TestMsg$            = "x1149 Boundary Scan Tests"            !x1149
SW_ScanPathVerifyMsg$    = "Scan Path Verify with ScanWorks"
SW_DrVerifyMsg$          = "DR Verify with ScanWorks"
SW_IrVerifyMsg$          = "IR Verify with ScanWorks"
SW_InterconnectMsg$      = "Interconnect with ScanWorks"
SW_MemInterconnectMsg$   = "Memory Interconnect with ScanWorks"
SW_ClusterMsg$           = "Cluster with ScanWorks"
SW_MemBistMsg$           = "Memory BIST with ScanWorks"
SW_ProgrammingMsg$       = "Programming Devices with ScanWorks"
SW_FlashMsg$             = "Programming Flash with ScanWorks"
VerifyGroundsMsg$        = "Verify Grounds"
FixturePowerMsg$         = "Setting Up Fixture Power Supplies"
CET_FixturePowerMsg$     = "Setting Up Fixture Power Supplies for CET"
Serial_Nr$               = "Serial #: "
BT_Passed$               = "passed"
BT_SR_Fail$              = "failed vector "
BT_CRC_Fail$             = "failed CRC is """
BT_Notest$               = "was not tested"
BT_Indeter$              = "was indeterminate"
BT_Interm$               = "was intermittent"
BT_Incons$               = "was inconsistent"
BT_Open$                 = "has an open trace"
BT_NResults$             = "noderesults= "
Chek_Point_Msg$          = "Testing Pin Contact"
Chek_Point_Msg2$         = "Testing Pin Long Contact"
Version_Label$           = ""
Version_Prompt$          = InvOn$&"Enter"&InvOff$&" Version Label: "
Serial_Number_Directory$ = "AXI_passed_boards/"
Serial_Suffix$           = ".SNF"
Not_AXI_Tested$          = "Board did not pass AXI; cannot test on Agilent ICT."
SNF_Error_Msg$           = "Error accessing serial number file. Error is: "
Bad_Board_Name$          = "Board name contains space, cannot proceed:"
Msg1$                    = "Flex Flow disable"
Msg2$                    = "Usuario no valido o password equivocado"
Msg_A$                   = "No puede probar"&" sin flujo"
Testt$                   = "GOL"&"DEN"
subend

!##############################################################################
sub Set_Custom_Options
!  All variables likely to need to be changed are initialized here.
!  The Usage flag(s) can be set True or False to selectively enable or
!  disable the code needed for each indicated subsystem or feature.

! IYET, WPR
global IYET_PinLong_Attempts
global Using_IYET, IYET_Shorts_Attempts, IYET_Analog_Tests_Attempts
global IYET_Report_On, IYET_VectorlessTest_Attempts, IYET_Preshorts_Attempts
global Using_WPR
global PMC_On ! Flag to enable/disable Power Monitoring Circuit (PMC)-For ASRU-N revision only
global IYET_Polarity_Check_Attempts, Using_Stopline

global Using_x1149


!   Usage flag(s)

Using_x1149                  = False     ! Choose (True or False) !x1149

QSTATS_Mode                  = Histo  ! Choose {Off, No_Histo, Histo}
Chek_Point_Mode              = Pretest   ! Choose {Off, Pretest, Failures}
Using_ART                    = True      ! Agilent Repair Tool.
Serializing                  = True      ! Will get set True if Using_ART.
Using_Buffered_Reporting     = True      ! Report failures during board handling
Programming                  = False     ! Execute Flash and device programming.
Using_IYET                   = True      ! Agilent Intelligent Yield Enhancement
                                         ! Test (IYET)
IYET_Report_On               = True      !   Create & display report on breaks
IYET_Preshorts_Attempts      = 6         !   Preshorts re-test attempts
IYET_Shorts_Attempts         = 6         !   Shorts re-test attempts
IYET_Analog_Tests_Attempts   = 6         !   Analog unp. re-test attempts
IYET_VectorlessTest_Attempts = 6         !   VectorlessTest re-test attempts
IYET_PinLong_Attempts        = 4         !   Long probe re-test attempts
Using_WPR                    = True      ! Agilent Worse Probe Report (WPR)
Using_Stopline               = true

!   Other parameters

!Report_Printer$           = btgetenv$("RPR"&th$) ! Final report destination
Report_Printer$           = "/dev/tty"  ! Send reports to the screen
Report_Printer$           = "fails"  ! Sen to "fails" file
Testrev$                  = "RevA"      ! Update this faithfully
Analog_Sample_Rate        = 1           ! Meaningful if QSTATS_Mode = Histo
Serial_Length             = 11          ! Board Id Length (0 = no checking)
Version_Prompting         = Per_Board   ! Choose {Per_Board, Per_Run}
                                        ! Used only on multiple version board
AXI_Tested_Override       = False       ! Choose {True, False}

PMC_On                    = False       ! Choose {True} to enable PMC, {False} to disable PMC
Autofile$                 = val$(autofile)   ! Fixture autofile #

call Verify_Autofile

subend

!##############################################################################
sub Cleanup_Flash
global Logging, Report_level$

if Report_level$ = "all" then report level is all
if Report_level$ = "none" then report level is none
if Report_level$ = "log" then report level is log
if Report_level$ = "report" then report level is report
if Logging then
  call Set_Log_Level
end if
subend

!       Data Logging Subroutines

!##############################################################################


!       IYET Subroutines

!##############################################################################
sub IYET_Initialize

global IYET_Path$, IYET_Failure_File$, IYET_Retest_Log_File$
global O$, InvOn$, InvOff$
global IYET_Vacuum_Off_Delay, IYET_Vacuum_On_Delay
global IYET_Report_On, IYET_Max_Report_Count, IYET_File_Timeout
global IYET_Err_Msg$, IYET_NoRT_Msg$
global IYET_Test_Msg$, IYET_Max_Msg$, IYET_Fail_Msg$
global IYET_Rpt1_Msg$, IYET_Rpt2_Msg$, IYET_Rpt3_Msg$
global Chek_Point_Mode, Max_Times_To_Fix_Contact, Failures, True, False

! Initialize paths and files
IYET_Path$                = "./iyet/"
IYET_Retest_Log_File$     = IYET_Path$&"retest"&datetime$[1;6]&".txt"
IYET_Failure_File$        = IYET_Path$&"failure.txt"

! Initialize variables
IYET_Vacuum_Off_Delay     = 3
IYET_Vacuum_On_Delay      = 3
IYET_Max_Report_Count     = 10
IYET_File_Timeout         = 5

! Initialize message strings
IYET_Err_Msg$  = "Error with file: "
IYET_NoRT_Msg$ = "No re-tests found or missing file: "
IYET_Test_Msg$ = "Re-testing "
IYET_Max_Msg$  = "Number of attempts for IYET must be > 0."
IYET_Fail_Msg$ = " failed, releasing board..."

! Initialize report strings
IYET_Rpt1_Msg$ = "IYET Unstable Test Report - from file: "
IYET_Rpt2_Msg$ = "Unstable Test"
IYET_Rpt3_Msg$ = "# Re-tests"

! When pins test is "Failures", disable redundant re-contacts
if Chek_Point_Mode = Failures then Max_Times_To_Fix_Contact = 1

! Create IYET directory
create dir IYET_Path$, Error
if (Error <> 100312) and (Error <> 0) then
   print IYET_Err_Msg$ & IYET_Path$
   print errmlong$(Error)
   beep
   stop
end if

! Generate and print re-test report
if (Error = 100312) and IYET_Report_On then
   print using "@"
 ! print IYET_Rpt1_Msg$ & IYET_Retest_Log_File$
 ! print
   call IYET_Create_Report
 ! print
   O$ = InvOn$&"Press YES"&InvOff$
   Prompt$ = O$&" to continue testing with IYET."
 ! question Prompt$, Continue
 ! if not Continue then stop
 ! print using "@"
end if
subend

!##############################################################################
sub IYET_Create_Report
! Collect all failing devices from log file and create retest report

global IYET_Retest_Log_File$
global IYET_Retest_Failing_Devices$(*), IYET_Top_Retests$(*)
global IYET_Max_Report_Count, IYET_File_Timeout
global IYET_NoRT_Msg$, IYET_Err_Msg$
global IYET_Rpt1_Msg$, IYET_Rpt2_Msg$, IYET_Rpt3_Msg$

! Open retest log file and get failing devices
assign @Retest_Log, Error to IYET_Retest_Log_File$;read
if Error then
   print IYET_NoRT_Msg$ & IYET_Retest_Log_File$
   print
   subexit
end if

! Read all failing devices until end of file or until IYET_File_Timeout.
Start_Time = msec
I = 0
loop
   Input$ = ""
   enter @Retest_Log,,Error;Input$
   if (Error <> 0) and (Error <> 101007) then
      print IYET_Err_Msg$ & IYET_Retest_Log_File$
      print errmlong$(Error)
      beep
      stop
   end if

   ! Look for shorts, vectorless test failures
   if pos(Input$," Report for """) then
      End_Input = pos(Input$,""".")
      Begin_Input = pos(Input$,"""") + 1
      Temp_device$ = Input$[Begin_Input;End_Input - Begin_Input]
      IYET_Retest_Failing_Devices$(I) = Temp_device$
      I = I + 1
   end if

   ! Look for analog failures
   if pos(Input$,"HAS FAILED") then
      IYET_Retest_Failing_Devices$(I) = Input$[1;pos(Input$,"HAS FAILED")-1]
      I = I + 1
   end if

   exit if Error = 101007

   if (msec - Start_Time)/1000 > IYET_File_Timeout then
      print IYET_Err_Msg$ & IYET_Retest_Log_File$
      beep
      stop
   end if
end loop

assign @Retest_Log to *
Device_Total = I-1

! Count failures and remove duplicates
K = 0
for I = 0 to Device_Total
   if IYET_Retest_Failing_Devices$(I) <> "" then
      Temp$ =  IYET_Retest_Failing_Devices$(I)
      Temp_Retests = 1
      for J = I + 1 to Device_Total
         if IYET_Retest_Failing_Devices$(J) <> "" then
            if Temp$ = IYET_Retest_Failing_Devices$(J) then
               Temp_Retests = Temp_Retests + 1
               IYET_Retest_Failing_Devices$(J) = ""
            end if
         end if
      next J
      IYET_Top_Retests$(K,1) = Temp$
      IYET_Top_Retests$(K,2) = val$(Temp_Retests)
      K = K + 1
   end if
next I
Top_Retest_Total = K-1

! Sort ascending
for I = 0 to Top_Retest_Total
   for J = Top_Retest_Total to 1 step -1
      if val(IYET_Top_Retests$(J,2)) > val(IYET_Top_Retests$(J-1,2)) then
         Temp$ = IYET_Top_Retests$(J-1,1)
         Temp_Retests = val(IYET_Top_Retests$(J-1,2))

         IYET_Top_Retests$(J-1,1) = IYET_Top_Retests$(J,1)
         IYET_Top_Retests$(J-1,2) = IYET_Top_Retests$(J,2)

         IYET_Top_Retests$(J,1) = Temp$
         IYET_Top_Retests$(J,2) = val$(Temp_Retests)
      end if
   next J
next I

! Print
IYET_Max_Report_Count = IYET_Max_Report_Count - 1
if Top_Retest_Total <= IYET_Max_Report_Count then
   IYET_Max_Report_Count = Top_Retest_Total
end if

print IYET_Rpt2_Msg$;tab (50);IYET_Rpt3_Msg$

for I = 0 to IYET_Max_Report_Count
   print IYET_Top_Retests$(I,1);tab (55);IYET_Top_Retests$(I,2)
next I
subend

!##############################################################################
sub IYET_Vacuum_Off
! Edit this subroutine to match your vacuum actuation commands. Note that the
! delay for vacuum off is completed in the "IYET_Vacuum_On" subroutine.

global IYET_Start_Vacuum_Off

IYET_Start_Vacuum_Off = msec
faoff 2.5
subend

!##############################################################################
sub IYET_Vacuum_On(Prompt$)
! Edit this subroutine to match your vacuum actuation commands. Do not
! comment the line:
!
!  question Prompt$,Continue | if not Continue then stop
!
! unless your fixture is approved for actuation without operator
! intervention.

global IYET_Start_Vacuum_Off, IYET_Vacuum_Off_Delay, IYET_Vacuum_On_Delay

!@question Prompt$,Continue | if not Continue then stop

! Wait for vacuum to release
loop
   exit if (msec - IYET_Start_Vacuum_Off)/1000 > IYET_Vacuum_Off_Delay
end loop

call Counter |  faon
subend

!##############################################################################
sub IYET_Get_Failed_Tests (IYET_Abort)
! Collect all failing tests from failure file.
! To save time, this is called between the vacuum off and vacuum on.

global IYET_Failing_Tests$(*), IYET_Test_Total, IYET_File_Timeout
global IYET_Failure_File$, IYET_Retest_Log_File$, IYET_Err_Msg$
global Report_Printer$, Serial$, True, False
dim Failing_Tests$(0:2047)[40]

  report "S/N:"&Serial$

  report out
  report out IYET_Failure_File$; over
  report out IYET_Retest_Log_File$;append

! Open failure ticket and get failing tests
assign @Ticket, Error to IYET_Failure_File$;read
if Error then
   print IYET_Err_Msg$ & IYET_Failure_File$
   print errmlong$(Error)
   beep
   stop
end if

! Read all failing tests until end of file or until IYET_File_Timeout.
Start_Time = msec
I = 0
IYET_Abort = False
loop
   Input$ = ""
   enter @Ticket,,Error;Input$
   if (Error <> 0) and (Error <> 101007) then
      print IYET_Err_Msg$ & IYET_Failure_File$
      print errmlong$(Error)
      beep
      stop
   end if

   ! Look for shorts, vectorless test failures
   if pos(Input$," Report for """) then
      End_Input = pos(Input$,""".")
      Begin_Input = pos(Input$,"""") + 1
      Failing_Tests$(I) = Input$[Begin_Input;End_Input - Begin_Input]
      I = I + 1
   end if

   ! Look for analog test failures
   if pos(Input$,"HAS FAILED") then
      Failing_Tests$(I) = Input$[1;pos(Input$,"HAS FAILED")-1]
      I = I + 1
   end if

   ! Look for compensation failures and set abort flag
   if pos(Input$,"Compensation capacitance has not been") then
      IYET_Abort = True
   end if

   exit if IYET_Abort

   exit if Error = 101007

   if (msec - Start_Time)/1000 > IYET_File_Timeout then
      print IYET_Err_Msg$ & IYET_Failure_File$
      beep
      stop
   end if
end loop

!remove duplicate tests
for K = 0 to I-1
   if Failing_Tests$(K) <> "" then
      Temp$ =  Failing_Tests$(K)
      for J = K + 1 to I-1
         if Failing_Tests$(J) <> "" then
            if Temp$ = Failing_Tests$(J) then
               Failing_Tests$(J) = ""
            end if
         end if
      next J
   end if
next K

I = 0
for J = 0 to K - 1
   if Failing_Tests$(J) <> "" then
      IYET_Failing_Tests$(I) = Failing_Tests$(J)
      I = I + 1
   end if
next J

assign @Ticket to *
IYET_Test_Total = I - 1

! Abort if no tests are found
if IYET_Test_Total < 0 then IYET_Abort = True

! Clear report buffer and failures unless aborted
if not IYET_Abort then
   report clear
   clear failures
end if
subend

!##############################################################################
sub IYET_Retest_Failed_Tests
global IYET_Failing_Tests$(*), IYET_Test_Total, IYET_Test_Msg$

for I = 0 to IYET_Test_Total
    print tab(11);IYET_Test_Msg$;lwc$(IYET_Failing_Tests$(I))
    test lwc$(IYET_Failing_Tests$(I))
next I
subend

!##############################################################################
sub IYET (TestType$, Maximum_Number_Attempts)
global Failed_In_Preshorts, PreshortsMsg$, Failed_In_Shorts, ShortsMsg$
global Failed_In_Analog, AnalogMsg$
global Failed_In_VectorlessTest, VectorlessTestMsg$
global Using_Buffered_Reporting, Logging, True, False, Mode$
global IYET_Fail_Msg$, Recycle_Vacuum$
global Long_Pin_Msg$, Failed_Long_Pin_Test

Retests_Remaining = dround(Maximum_Number_Attempts,1) + 1

! Force log level, will be restored by Cleanup_Flash
if Logging then
  log level is all  !log level is non  !changed by tool
end if

! Force buffered reporting, save flag to restore at end
if not Using_Buffered_Reporting then
   buffered reporting on
   Not_Using_Buffered_Reporting = True
end if

! Call the test subroutine for the first time...
if TestType$ = PreshortsMsg$ then
   call Pre_Shorts (Failed_In_Preshorts, Mode$ & PreshortsMsg$)
end if

if TestType$ = ShortsMsg$ then
   call Shorts (Failed_In_Shorts, Mode$ & ShortsMsg$)
end if

if TestType$ = AnalogMsg$ then
   call Analog_Tests (Failed_In_Analog, Mode$ & AnalogMsg$)
end if

if TestType$ = VectorlessTestMsg$ then
   call VectorlessTest (Failed_In_VectorlessTest, Mode$ & VectorlessTestMsg$)
end if

if TestType$ = Long_Pin_Msg$ then
 call Long_Pin_Tests (Failed_Long_Pin_Test, Mode$ & Long_Pin_Msg$)
end if

Retests_Remaining = Retests_Remaining - 1

loop

   ! Exit if attempt is successful
   exit if (not boardfailed)

   ! Exit if done with re-tests
   exit if (Retests_Remaining = 0)

   ! Process failures during vacuum cycle time
   print tab(8);TestType$ & IYET_Fail_Msg$
   if TestType$ = Long_Pin_Msg$ then
     auxdisconnect 5 | wait 3
   end if
   call IYET_Vacuum_Off
   call IYET_Get_Failed_Tests (IYET_Abort)
   call IYET_Vacuum_On(Recycle_Vacuum$)

   if TestType$ = Long_Pin_Msg$ then
     faoff|wait 2| auxconnect 5 |wait 3  |unpowered
   end if

   ! Exit if aborted
   exit if IYET_Abort

   ! For last time through the loop, restore logging and reporting
   if Retests_Remaining = 1 then call Cleanup_Flash

   ! Re-test
   call IYET_Retest_Failed_Tests
   Retests_Remaining = Retests_Remaining - 1

end loop

! Now some clean up. Could be redundant.

! Restore Log & Report level
call Cleanup_Flash

! Restore 'unbuffered' reporting, after dumping report buffer
if Not_Using_Buffered_Reporting then
   if boardfailed then report out
   buffered reporting off
end if
subend


!-----------------------------------------------------------------!x1149
sub X1149_Initialize_Connection                                   !x1149
global DLL_Handle, ABS_Project$, ABS_IPAddress$
global X1149Msg$,X1149_Connected$

dllload "x1149Wrapper.dll", DLL_Handle

dllcall DLL_Handle, "Initx1149Engine", X1149Result, X1149Msg$
print tab(5);X1149Msg$

dllcall DLL_Handle, "OpenProject", X1149Result, X1149Msg$; ABS_Project$
print tab(5);X1149Msg$

dllcall DLL_Handle, "ConnectToHardware", X1149Result, X1149Msg$; ABS_IPAddress$
print tab(5);X1149Msg$

X1149_Connected$ = "1"

subend ! (X1149_Initialize_Connection)                            !x1149

!-----------------------------------------------------------------!x1149
sub Setup_Power_Supplies_x1149_Setup (Status_Code, Message$)

print "Please set up the power supply configuration for x1149 Setup here"

subend

!-----------------------------------------------------------------!x1149
sub X1149_BScan_Tests (Status_Code, Message$)
global DLL_Handle
global X1149Msg$

 print ""
 if Message$ <> "" then  print tab(5);Message$

dllcall DLL_Handle, "ExecuteTest", X1149Result, X1149Msg$, Error;"chain_name,test_name"
if Error then print "chain_name,test_name"; "has ERROR"
print "      "&X1149Msg$
if (pos(lwc$(X1149Msg$), "passed") = 0) then
  report X1149Msg$
  fail device
end if

subend !(X1149_BScan_Tests)
!-----------------------------------------------------------------!x1149
sub Get_Version
   !Get operator to scan  board assembly and version that is to be tested.
   !Enter the ISO information for each version here. This will be printed
   !by sub Print_Heading just above the sub Test_Sections messages.
   !Include any optional information, variables, etc. as desired.
   global Board$, Board_Rev$, Line$
   global Option, Selection, Assembly$, Scan_Count, Dev, Devia$
   global Deviation_Log$, Num_Dev, Dev_Count
   global Assy_73$, Assy_73_Rev$, Assy_800$, Assy_800_Rev$
   global Option_short, Option_Elpd ,Option_D095428
   global MAC_Addr$
   global Red$, Yellow$, Blue$, Green$, Magenta$, Black$

   InvOn$  = chr$(27)&"&dB"&chr$(7)  ! chr$(7) rings bell
   InvOff$ = chr$(27)&"&d@"

   Choose_Board_Version:
!<***************************************************************************>
!<--------------------------------------------------------------------------->
!<----- ALL VARIABLES & OPTIONS ADDED MUST BE SET TO 0 HERE ----------------->
!<--------------------------------------------------------------------------->
!<***************************************************************************>

   Assembly$      = ""   !clear variables if program loops
   Board$         = ""
   Board_Rev$     = ""
   Deviation_Log$ = ""
   Num_Dev        = 0
   Option_short   = 0
   Option_Elpd    = 0
   Option_D095428 = 0
   MAC_Addr$      = ""

loop
   print Black$ & "Scan ASSEMBLY BARCODE on board"
  input Assembly$
   Ens = 0

  if Assembly$ = "73-18922-05 C0"  or Assembly$ = "73-18922-05 D0" then
      Assembly$ = trim$(upc$(Assembly$))
      A=len(Assembly$)
      Board$ = Assembly$[1;A-3]
      Board_Rev$ = Assembly$[A-1;2]
      print tab(10); Yellow$& "El UUT Type es: "& Board$
      print tab(10); Yellow$&"Cantidad de caracteres : "; A
      print tab(10); Yellow$&"La Revision es: "& Board_Rev$
      Assy_73$        =  Assembly$[1;A-3]
      Assy_73_Rev$    =  Assembly$[A-1;2]
      Assy_800$       = ""
      Assy_800_Rev$   = ""
      Ens = 1
  end if


   exit if Ens =1
   print;Red$&"Ensamble equivocado"
   print ""

end loop

subend
!############################################################################

sub Verify_Autofile
global Red$, Blue$, Yellow$, Black$
global Autofile$, Stop_Msg$, FixID$,ReadID$
global Fix_Type$, Model_Type$,Rfid$

Model_Type$ = "DC-PINEDROPS"

if Autofile$ = "3432" then
  Fix_Type$ = "Fixture_199"
  Rfid$ = "0284241"
  print tab(22);Black$&"Fixture Detected: ";Fix_Type$
  print tab(22);Black$&"Model: ";Model_Type$
  print tab(22);Black$&"Fixture RFID: ";Rfid$
  goto Val_auto
end if

if Autofile$ = "3431" then
  Fix_Type$ = "Fixture_190"
  Rfid$ = "0284239"
  print tab(22);Black$&"Fixture Detected: ";Fix_Type$
  print tab(22);Black$&"Model: ";Model_Type$
  print tab(22);Black$&"Fixture RFID: ";Rfid$
  goto Val_auto
end if

if Autofile$ = "3430" then
  Fix_Type$ = "Fixture_146"
  Rfid$ = "0284456"
  print tab(22);Black$&"Fixture Detected: ";Fix_Type$
  print tab(22);Black$&"Model: ";Model_Type$
  print tab(22);Black$&"Fixture RFID: ";Rfid$
  goto Val_auto
end if

print tab(13);Red$&"***********************************************************"
print tab(13);Red$&"***** TENGA CUIDADO!!, EL PROGRAMA QUE INTENTA CARGAR *****"
print tab(13);Red$&"*****       NO ES EL INDICADO PARA ESTE FIXTURE       *****"
print tab(13);Red$&"*****     POR FAVOR CONTACE A UN ING. DE PRUEBAS      *****"
print tab(13);Red$&"***********************************************************"
stop
Val_auto:

subend
!************************END AUTOFILE VALIDATION******************************

sub Fixture_SET
  global Flex_Flow, Serial_golden$

  if Serial_golden$ = "unidad golden" then
  Flex_Flow = 0
  else
  Flex_Flow = 1
  end if

subend

sub Validation_FF
global Serial$, MAC_Addr$, Assembly$, Black$
global FF_V, SIL, SIL2,Board_Rev$,Board$, Serial_golden$

execute "> PART"
execute "> PARTREV"
Result1$ = ""
Result12$= ""


  if Serial_golden$ = "unidad golden" then goto GOLDEND

  execute "ffeticlient -INFO " & Serial$ & " > ffeticlient2.out", Error;nowait,append
  enter "ffeticlient2.out";Vali$
  if Vali$[1;2]="{O" then
      execute "grep -i 'PartNumber' ffeticlient2.out > PART"
      execute "grep -i 'PartRevision' ffeticlient2.out > PARTREV"
  end if
    if Vali$[1;2]="{E" then
       FF_V = 1
       print chr$(27)&"&v3S****** LA UNIDAD NO TIENE FLUJO **********"
       print chr$(27)&"&v3S****FAVOR DE VALIDAR EL FLUJO DE LA UNIDAD*****"
       goto End
    end if


 enter "PART" ;Result1$
 enter "PARTREV" ;Result12$
 Num = pos(Result1$,"73")
 if Num = 0 then Num=pos(Result1$,"800")
 Num2 = pos(Result12$, "=-")
 FF_V = 0

 if Result1$[Num;12] = "800-47972-04" then
     Result1$ = "PartNumber=CIS-"&Board$
     Result12$[Num2+2;2] = Board_Rev$
     Num = 16
 end if

Ensrev$ = Result1$[Num;12] &" "& Result12$[Num2+2;2]

if Ensrev$<>Assembly$  then
     print chr$(27)&"&v3S******** NUMERO DE PARTE INCORRECTO **********"
     print chr$(27)&"&v3S***EL SIGUIENTE: "&Serial$&" PERTENECE**********"
     print chr$(27)&"&v3SE*** AL NUMERO DE PARTE: "&Ensrev$&" EN FLEX FLOW"
     print chr$(27)&"&v3S*****FAVOR DE VALIDAR CON TU SUPERVISOR*************"
     FF_V = 1
     goto End
  else
      print chr$(27)&"&v2S*********  Tarjeta Valida para probar en ICT *******"
      print chr$(27)&"&v2S      Presione YES para comenzar la pra de ICT.."

end if

GOLDEND:
FF_V = 0

End:
subend
!                          END OF TESTMAIN
!##############################################################################


sub Initialize_Board_Constants
global Board$,Board_Rev$
global Using_Multiple_Versions, True, False
global Using_AwareTest

!@ Board$ = "73-18922-05"
!@ Board_Rev$ = "C0"

! 'vacuum well' statement goes here (if required)
   vacuum well a is 0,1,2,3
   Using_Multiple_Versions = False
   Using_AwareTest = False
subend

sub Setup_FXT_Power_Supplies (Status_Code, Message$)
subend

sub Setup_CET_FXT_Power_Supplies (Status_Code, Message$)
subend

sub Disconnect_FXT_Power_Supplies
subend

sub Characterize
global Status, Failed_In_Learn

   Status = Failed_In_Learn
   learn capacitance on
   test "analog/c05_mvr"
   test "analog/c05_vr"
   test "analog/c06_mvr"
   test "analog/c9_adv"
   test "analog/c17"
   test "analog/c18"
   test "analog/c19"
   test "analog/c20"
   test "analog/c21"
   test "analog/c229"
   test "analog/c237"
   test "analog/c238"
   test "analog/c348"
!@ test "analog/c10_cp"    !10pf,Small value,no test require
!@ test "analog/c11_cp"    !15pf,Small value,no test require
!@ test "analog/c12_cp"    !15pf,Small value,no test require
!@ test "analog/c114_cp"   !27pf,Small value,no test require
!@ test "analog/c115_cp"   !27pf,Small value,no test require
!@ test "analog/c117_cp"   !27pf,Small value,no test require
!@ test "analog/c118_cp"   !27pf,Small value,no test require
   learn capacitance off
subend

sub Long_Pin_Tests (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code

   faoff|wait 2| auxconnect 5 |wait 3  |unpowered

   test "pins_long"                  !detect long probe
!  test "short_stroke"               !detect short probe
   test "analog/power_relay_check"   !check relay close for power test

subend

sub Pre_Shorts (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
   test "analog/r3_98_mvr"
!  test "analog/l1_f%jp1_8"                             ! Nostuff
!  test "analog/l1_f%jp2_7"                             ! Nostuff
!  test "analog/l1_f%jp3_6"                             ! Nostuff
!  test "analog/l1_f%jp4_5"                             ! Nostuff
!  test "analog/l2_f%jp1_8"                             ! Nostuff
!  test "analog/l2_f%jp2_7"                             ! Nostuff
!  test "analog/l2_f%jp3_6"                             ! Nostuff
!  test "analog/l3_f%jp1_8"                             ! Nostuff
!  test "analog/l3_f%jp2_7"                             ! Nostuff
!  test "analog/l3_f%jp3_6"                             ! Nostuff
! test "analog/l4_f%jp1_8"                             ! Nostuff
!  test "analog/l4_f%jp2_7"                             ! Nostuff
!  test "analog/l4_f%jp3_6"                             ! Nostuff
!  test "analog/l4_f%jp4_5"                             ! Nostuff
!  test "analog/l12_f%jp1_8"                            ! Nostuff
!  test "analog/l12_f%jp2_7"                            ! Nostuff
!  test "analog/l12_f%jp3_6"                            ! Nostuff
!  test "analog/l12_f%jp4_5"                            ! Nostuff
!  test "analog/l666_f%jp1_8"                           ! Nostuff
!  test "analog/l666_f%jp2_7"                           ! Nostuff
!  test "analog/l666_f%jp3_6"                           ! Nostuff
   test "analog/b1%presence"
   test "analog/fancon01_f%presence"                    ! Nostuff
   test "analog/fancon23_f%presence"                    ! Nostuff
   test "analog/fancon45_f%presence"                    ! Nostuff
   test "analog/io_p1%presence"
   test "analog/io_p2%presence"
!@ test "analog/j1%presence"                             !@no stuff BY ECO
!  test "analog/j3%presence"                            ! Nostuff
   test "analog/m2%presence"
!  test "analog/m1%presence"                            ! Nostuff
!  test "analog/m4%presence"                            ! Nostuff
!  test "analog/p1_cp%presence"                         ! Nostuff
!@ test "analog/p1_mvr%presence"                        ! for 73-19246-05 A0
!@ test "analog/p1_vr%presence"                         ! for 73-19246-05 A0
!  test "analog/p3%presence"                            ! Nostuff
!  test "analog/p6_cp%presence"                         ! Nostuff
!  test "analog/p7%presence"                            ! Nostuff
!  test "analog/p8%presence"                            ! Nostuff
!  test "analog/p9%presence"                            ! Nostuff
!  test "analog/spi_cp%presence"                        ! Nostuff
!  test "analog/sw3_cp%presence"                        ! Nostuff
!  test "analog/tpm_cp%presence"                        ! Nostuff
!  test "analog/p2%presence"                            ! Nostuff
!  test "analog/p6%presence"                            ! Nostuff
!  test "analog/ts%presence"                            ! Nostuff
   test "analog/h2280%presence"
   test "analog/u10_cp%presence"
!  gpconnect 20660 to 20661|wait 200m        !connect 24V
!  auxconnect 5|wait 1
!  test "analog/sw1_cp%presence"
!  test "analog/sw2_cp%presence"
!  auxdisconnect 5
!  gpdisconnect 20660 from 20661
subend

sub Shorts (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
   test "shorts"
subend

sub Analog_Tests (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
   test "analog/a_c810"                           ! Parallel w/ > 5 devices
   test "analog/c13_91_vr"                        ! Parallel w/ > 5 devices
   test "analog/c9_5v"                            ! Parallel
   test "analog/c226"                             ! Parallel w/ > 5 devices
   test "analog/c9_vpp"                           ! Parallel w/ > 5 devices
   test "analog/c8_5v"                            ! Parallel w/ > 5 devices
   test "analog/c214"                             ! Parallel w/ > 5 devices
   test "analog/c8_vpp"                           ! Parallel w/ > 5 devices
   test "analog/c92_cp"                           ! Parallel w/ > 5 devices
   test "analog/c120_cp"                          ! Parallel w/ > 5 devices
   test "analog/c252"                             ! Parallel w/ > 5 devices
   test "analog/c254"                             ! Parallel
   test "analog/c87"                              ! Parallel w/ > 5 devices
   test "analog/c227"                             ! Parallel w/ > 5 devices
   test "analog/c3283"                            ! Parallel
   test "analog/c3"                               ! Parallel w/ > 5 devices
   test "analog/c11_3v3"                          ! Parallel w/ > 5 devices
   test "analog/io_c23"                           ! Parallel
!@@test "analog/c06_91_mvr"        !top side
!@@test "analog/c06_98_mvr"        !top side
!@@test "analog/c01_mvr"           !In parallel with u1_mvr,unstable
!@@test "analog/c01_vr"            !In parallel with u1_vr,unstable
!@@test "analog/c02_mvr"           !In parallel with u1_mvr,unstable
   test "analog/c2_5v"
   test "analog/c2_adv"
   test "analog/c2_vpp"
   test "analog/c5_5v"
   test "analog/c5_adv"
   test "analog/c5_vpp"
   test "analog/c09_mvr"                          ! Parallel
   test "analog/c09_vr"                           ! Parallel
   test "analog/c08_3v3"
   test "analog/c13"                              ! Parallel
   test "analog/c57"
   test "analog/c58"
   test "analog/c24_cp"                           ! Parallel
   test "analog/c119_cp"                          ! Parallel
   test "analog/c133_cp"                          ! Parallel
   test "analog/c135_cp"
   test "analog/c136_cp"
   test "analog/c233"
   test "analog/c291"                             ! Parallel
   test "analog/c303"
   test "analog/c06_3v3"
   test "analog/c7_5v"
   test "analog/c7_adv"
   test "analog/c7_vpp"
   test "analog/c13_cp"
   test "analog/c14_cp"
   test "analog/c15_cp"
   test "analog/c16_cp"
   test "analog/c17_cp"
   test "analog/c18_cp"
   test "analog/c105_cp"
   test "analog/c110_cp"
   test "analog/c112_cp"
 !!test "analog/c178_cp"       !TMP
   test "analog/c216"
   test "analog/c218"                             ! Parallel w/ > 5 devices
   test "analog/c302"                             ! Parallel
   test "analog/c03_mvr"                          ! Parallel
   test "analog/c03_vr"                           ! Parallel
   test "analog/c04_mvr"                          ! Parallel
   test "analog/c04_vr"                           ! Parallel
   test "analog/c10_mvr"                          ! Parallel
   test "analog/c10_vr"                           ! Parallel
   looptest25"analog/c100"
   test "analog/c05_mvr"
   test "analog/c05_vr"
   test "analog/c06_mvr"
!@@test "analog/c06_91_vr"   !top side
!@@test "analog/c06_92_vr"   !top side
   test "analog/c9_adv"
!@ test "analog/c10_cp"    !10pf
!@ test "analog/c11_cp"    !15pf
!@ test "analog/c12_cp"    !15pf
!@ test "analog/c114_cp"   !27pf
!@ test "analog/c115_cp"   !27pf
!@ test "analog/c117_cp"   !27pf
!@ test "analog/c118_cp"   !27pf
   test "analog/c17"
   test "analog/c18"
   test "analog/c19"
   test "analog/c20"
   test "analog/c21"
   test "analog/c229"
   test "analog/c237"
   test "analog/c238"
   test "analog/c348"
   test "analog/r1_5v"
   test "analog/r1_adv"
   test "analog/r1_vpp"
   test "analog/r3_5v"
   test "analog/r3_adv"
   test "analog/r3_vpp"
   test "analog/r325"
   test "analog/r323"
   test "analog/r23_mvr"
   test "analog/r30"
   test "analog/r31"
   test "analog/r78_cp"
   test "analog/r79_cp"
   test "analog/r80_cp"
   test "analog/r81_cp"
   test "analog/r90_cp"
   test "analog/r91_cp"
   test "analog/r107_cp"
   test "analog/r108_cp"
   test "analog/r111_cp"
   test "analog/r112_cp"
   test "analog/r113_cp"
   test "analog/r114_cp"
   test "analog/r115_cp"
   test "analog/r118_cp"
   test "analog/r130_cp"
   test "analog/r135_cp"
   test "analog/r138_cp"
   test "analog/r139_cp"
   test "analog/r140_cp"
   test "analog/r141_cp"
   test "analog/r142_cp"
   test "analog/r143_cp"
   test "analog/r144_cp"
   test "analog/r145_cp"
   test "analog/r153"
   test "analog/r158_cp"
   test "analog/r161_cp"
   test "analog/r163_cp"
   test "analog/r164_cp"
   test "analog/r165_cp"
   test "analog/r166_cp"
   test "analog/r167_cp"
   test "analog/r168_cp"
   test "analog/r171"
   test "analog/r171_cp"
   test "analog/r179"
   test "analog/r182"
   test "analog/r199"
   test "analog/r200"
   test "analog/r201_cp"
   test "analog/r202_cp"
   test "analog/r203_cp"
   test "analog/r205_cp"
   test "analog/r208_cp"
   test "analog/r211_cp"
   test "analog/r213_cp"
   test "analog/r215_cp"
   test "analog/r226"
   test "analog/r227"
   test "analog/r234_cp"
   test "analog/r236_cp"
   test "analog/r241_cp"
   test "analog/r250_cp"
   test "analog/r256_cp"
   test "analog/r272_cp"
   test "analog/r277_cp"
   test "analog/r278"
   test "analog/r279"
   test "analog/r280_cp"
   test "analog/r282_cp"
   test "analog/r284_cp"
   test "analog/r285"
   test "analog/r286"
   test "analog/r286_cp"
   test "analog/r287"
   test "analog/r287_cp"
   test "analog/r315_cp"
   test "analog/r316_cp"
   test "analog/r317_cp"
   test "analog/r318_cp"
   test "analog/r328_cp"
!  test "analog/r343_cp"
   test "analog/r344_cp"
   test "analog/r348"
   test "analog/r358_cp"
   test "analog/r359_cp"
   test "analog/r362_cp"
   test "analog/r366_cp"
   test "analog/r367_cp"
   test "analog/r381_cp"
   test "analog/r410_cp"
   test "analog/r411_cp"
   test "analog/r427_cp"
   test "analog/r428_cp"
   test "analog/r437_cp"
   test "analog/r438_cp"
   test "analog/r521"
   test "analog/r539"
   test "analog/r645"
   test "analog/r661"
   test "analog/r1712"
   test "analog/r01_mvr"
   test "analog/r03_mvr"
   test "analog/r03_vr"
   test "analog/r319_cp"
   test "analog/r321_cp"
   test "analog/r322_cp"
   test "analog/r529"
   test "analog/r2_adv"
   test "analog/r4_vpp"
   test "analog/r4_3v3"
   test "analog/r105_cp"
   test "analog/r179_cp"
   test "analog/r243"
   test "analog/r244"
   test "analog/r435"
   test "analog/r436"
   test "analog/r501"
   test "analog/r4_5v"
   test "analog/r5_3v3"
   test "analog/r4_adv"
   test "analog/r5_5v"
   test "analog/r5_vpp"
   test "analog/r307"
   test "analog/r352"
   test "analog/r09_mvr"
   test "analog/r09_vr"
   test "analog/r11_mvr"
   test "analog/r11_vr"
   test "analog/r12_vr"
   test "analog/r18_mvr"
   test "analog/r67"
   test "analog/r68"
   test "analog/r69"
   test "analog/r94_cp"
   test "analog/r103_cp"
   test "analog/r104_cp"
   test "analog/r120_cp"
   test "analog/r121_cp"
   test "analog/r122_cp"
   test "analog/r136_cp"
   test "analog/r154"
   test "analog/r154_cp"
   test "analog/r156"
   test "analog/r174_cp"
   test "analog/r175_cp"
   test "analog/r178_cp"
   test "analog/r204_cp"
   test "analog/r210"
   test "analog/r211"
   test "analog/r212"
   test "analog/r213"
   test "analog/r214"
   test "analog/r220_cp"
   test "analog/r221_cp"
   test "analog/r222_cp"
   test "analog/r225_cp"
   test "analog/r248_cp"
   test "analog/r251_cp"
   test "analog/r252_cp"
   test "analog/r253_cp"
   test "analog/r254_cp"
   test "analog/r255_cp"
   test "analog/r257_cp"
   test "analog/r258_cp"
   test "analog/r259_cp"
   test "analog/r260_cp"
   test "analog/r262_cp"
   test "analog/r265_cp"
   test "analog/r266_cp"
   test "analog/r267_cp"
   test "analog/r268_cp"
   test "analog/r273_cp"
   test "analog/r275_cp"
   test "analog/r276_cp"
   test "analog/r277"
   test "analog/r279_cp"
   test "analog/r283_cp"
   test "analog/r285_cp"
   test "analog/r288_cp"
   test "analog/r290_cp"
   test "analog/r291_cp"
   test "analog/r294_cp"
   test "analog/r297_cp"
   test "analog/r307_cp"
   test "analog/r309"
   test "analog/r314"
   test "analog/r320_cp"
   test "analog/r324_cp"
   test "analog/r328"
   test "analog/r329"
   test "analog/r330"
   test "analog/r355_cp"
   test "analog/r356_cp"
   test "analog/r364_cp"
   test "analog/r373_cp"
   test "analog/r374_cp"
   test "analog/r384_cp"
   test "analog/r392_cp"
   test "analog/r393_cp"
   test "analog/r394_cp"
   test "analog/r395_cp"
   test "analog/r401_cp"
   test "analog/r409_cp"
   test "analog/r415_cp"
   test "analog/r423_cp"
   test "analog/r425_cp"
   test "analog/r433"
   test "analog/r433_cp"
   test "analog/r490"
   test "analog/r935"
   test "analog/r2265"
   test "analog/r10_mvr"
   test "analog/r10_vr"
   test "analog/r25_mvr"
   test "analog/r25_vr"
   test "analog/r20_mvr"
   test "analog/r21_mvr"
   test "analog/r21_vr"
   test "analog/r29_mvr"
   test "analog/r29_vr"
   test "analog/r133_cp"
   test "analog/r149_cp"
   test "analog/r150_cp"
   test "analog/r212_cp"
   test "analog/r232_cp"
   test "analog/r233_cp"
   test "analog/r292_cp"
   test "analog/r304"
   test "analog/r312"
   test "analog/r329_cp"
   test "analog/r332_cp"
   test "analog/r333_cp"
   test "analog/r334_cp"
   test "analog/r24_mvr"
   test "analog/r24_vr"
   test "analog/r29"
   test "analog/r34"
   test "analog/r35"
   test "analog/r58"
   test "analog/r59"
   test "analog/r126_cp"
   test "analog/r159"
   test "analog/r162"
   test "analog/r163"
   test "analog/r172_cp"
   test "analog/r178"
   test "analog/r180"
   test "analog/r195"
   test "analog/r196"
   test "analog/r210_cp"
   test "analog/r215"
   test "analog/r216"
   test "analog/r217"
   test "analog/r218"
   test "analog/r219"
   test "analog/r221"
   test "analog/r228"
   test "analog/r235"
   test "analog/r245"
   test "analog/r255"
   test "analog/r256"
   test "analog/r257"
   test "analog/r258"
   test "analog/r259"
   test "analog/r261"
   test "analog/r270"
   test "analog/r289"
   test "analog/r293"
   test "analog/r294"
   test "analog/r326"
   test "analog/r326_cp"
   test "analog/r342"
   test "analog/r347"
   test "analog/r370"
   test "analog/r380"
   test "analog/r412"
!@ test "analog/r417"        !@@ Base Damge "PCH_GP72_FPGA_PERST_L"
   test "analog/r418"
   test "analog/r419"
   test "analog/r424"
   test "analog/r425"
   test "analog/r426"
   test "analog/r427"
   test "analog/r434"
   test "analog/r475"
   test "analog/r485"
   test "analog/r486"
   test "analog/r494"
   test "analog/r495"
   test "analog/r502"
   test "analog/r541"
   test "analog/r576"
   test "analog/r577"
   test "analog/r579"
   test "analog/r35_cp"
!@ test "analog/r195_cp"     !not install for 73-19246-05 A0
!@ test "analog/r124_cp"   !base capada
!@ test "analog/r125_cp"    !base danada  !EMG
!@ test "analog/r128_cp"  !base danada   !jcg
!@ test "analog/r129_cp"  !base danada   !jcg
   test "analog/r134_cp"
   test "analog/r184_cp"
   test "analog/r185_cp"
   test "analog/r186_cp"
   test "analog/r187_cp"
   test "analog/r188_cp"
   test "analog/r189_cp"
   test "analog/r190_cp"
   test "analog/r191_cp"
   test "analog/r192_cp"
   test "analog/r193_cp"
   test "analog/r194_cp"
   test "analog/r196_cp"
   test "analog/r197_cp"
   test "analog/r198_cp"
   test "analog/r199_cp"
   test "analog/r200_cp"
   test "analog/r209_cp"
   test "analog/r214_cp"
   test "analog/r216_cp"
   test "analog/r217_cp"
   test "analog/r218_cp"
   test "analog/r237_cp"
   test "analog/r238_cp"
   test "analog/r239_cp"
   test "analog/r240_cp"
   test "analog/r242_cp"
   test "analog/r243_cp"
   test "analog/r244_cp"
   test "analog/r245_cp"
!@ test "analog/r37"      !probe removed
   test "analog/r207"
   test "analog/r314_cp"
!  test "analog/r360_cp"
   test "analog/r365_cp"
   test "analog/r402_cp"
   test "analog/r424_cp"
   test "analog/r667"
   test "analog/r668"
   test "analog/r40"
   test "analog/r41"
   test "analog/r60"
   test "analog/r61"
   test "analog/r146_cp"
   test "analog/r147_cp"
   test "analog/r148_cp"
   test "analog/r246_cp"
   test "analog/r296_cp"
   test "analog/r298_cp"
   test "analog/r435_cp"
   test "analog/r471"
   test "analog/r472"
   test "analog/r473"
   test "analog/r474"
   test "analog/r62"
   test "analog/r66"
   test "analog/r300_cp"
   test "analog/r397_cp"
   test "analog/r398_cp"
   test "analog/r439_cp"
   test "analog/r64"
   test "analog/r65"
   test "analog/r187"
   test "analog/r188"
   test "analog/r189"
   test "analog/r190"
   test "analog/r193"
   test "analog/r194"
   test "analog/r206_cp"
   test "analog/r288"
   test "analog/r448"
   test "analog/r449"
   test "analog/r669"
   test "analog/r670"
   test "analog/r671"
   test "analog/r672"
   test "analog/r673"
   test "analog/r82_cp"
   test "analog/r83_cp"
   test "analog/r99_cp"
   test "analog/r375_cp"
   test "analog/r376_cp"
   test "analog/r86_cp"
   test "analog/r87_cp"
   test "analog/r477"
   test "analog/r88_cp"
   test "analog/r89_cp"
   test "analog/r98_cp"
   test "analog/r106_cp"
   test "analog/r116_cp"
   test "analog/r92_cp"
   test "analog/r95_cp"
   test "analog/r180_cp"
   test "analog/r181_cp"
   test "analog/r371_cp"
   test "analog/r372_cp"
   test "analog/r101_cp"
   test "analog/r102_cp"
   test "analog/r123_cp"
!! test "analog/r274_cp"  !TMP
   test "analog/r334"
   test "analog/r117_cp"
   test "analog/r235_cp"
   test "analog/r119_cp"
   test "analog/r170_cp"
   test "analog/r247_cp"
   test "analog/r270_cp"
   test "analog/r271_cp"
   test "analog/r278_cp"
   test "analog/r295_cp"
   test "analog/r127_cp"
   test "analog/r160_cp"
   test "analog/r147"
   test "analog/r174"
   test "analog/r175"
!@@test "analog/r390_cp"    !top side
   test "analog/r391_cp"
   test "analog/r405_cp"
   test "analog/r406_cp"
   test "analog/r447"
   test "analog/r498"
   test "analog/r499"
   test "analog/r500"
   test "analog/r525"
   test "analog/r526"
   test "analog/r151_cp"
   test "analog/r152_cp"
   test "analog/r224_cp"
   test "analog/r226_cp"
   test "analog/r227_cp"
   test "analog/r229_cp"
   test "analog/r230_cp"
   test "analog/r231_cp"
   test "analog/r299_cp"
   test "analog/r382_cp"
!@ test "analog/r153_cp"
   test "analog/r240"
   test "analog/r241"
   test "analog/r276"
   test "analog/r283"
   test "analog/r284"
   test "analog/r292"
   test "analog/r301_cp"
   test "analog/r302_cp"
   test "analog/r325_cp"
   test "analog/r331_cp"
   test "analog/r349"
!@ test "analog/r350"               !@probe remove kill powere-jerry
   test "analog/r437"
   test "analog/r438"
   test "analog/r155"
   test "analog/r310"
   test "analog/r315"
   test "analog/r169_cp"
   test "analog/r177_cp"
   test "analog/r353"
   test "analog/r182_cp"
   test "analog/r183_cp"
   test "analog/r222"
   test "analog/r223"
   test "analog/r343"
   test "analog/r344"
   test "analog/r345"
   test "analog/r346"
   test "analog/r228_cp"
   test "analog/r249_cp"
   test "analog/r460"
   test "analog/r462"
   test "analog/r483"
   test "analog/r263_cp"
 ! test "analog/r417_cp"   !@@ Base Damge "PCH_GP72_FPGA_PERST_L"
!@@test "analog/r303_cp"   !top side
   test "analog/r305_cp"
   test "analog/r306_cp"
   test "analog/r304_cp"
   test "analog/r305"
   test "analog/r306"
   test "analog/r308"
   test "analog/r383"
   test "analog/r383_cp"
   test "analog/r457"
   test "analog/r308_cp"
   test "analog/r311_cp"
   test "analog/r351"
   test "analog/r309_cp"
   test "analog/r310_cp"
   test "analog/r312_cp"
   test "analog/r313"
   test "analog/r323_cp"
   test "analog/r335"
   test "analog/r385_cp"
   test "analog/r386_cp"
   test "analog/r387_cp"
   test "analog/r388_cp"
   test "analog/r389_cp"
   test "analog/r407_cp"
   test "analog/r429_cp"
   test "analog/r431_cp"
   test "analog/r530"
   test "analog/r531"
   test "analog/r580"
   test "analog/r336_cp"
   test "analog/r338"
   test "analog/r375"
   test "analog/r478"
   test "analog/r377_cp"
   test "analog/r378_cp"
   test "analog/r379_cp"
   test "analog/r380_cp"
!  test "analog/r419_cp"
   test "analog/r420_cp"
   test "analog/r421_cp"
   test "analog/r422_cp"
   test "analog/r399_cp"
   test "analog/r408"
   test "analog/r414_cp"
   test "analog/r451"
   test "analog/r452"
   test "analog/r453"
   test "analog/r454"
   test "analog/r455"
   test "analog/r456"
   test "analog/r491"
   test "analog/r492"
   test "analog/r496"
   test "analog/r497"
   test "analog/r493"
   test "analog/r504"
   test "analog/r513"
   test "analog/r514"
   test "analog/r515"
   test "analog/r516"
   test "analog/r517"
   test "analog/r518"
   test "analog/r519"
   test "analog/r520"
   test "analog/r522"
   test "analog/r523"
   test "analog/r666"
   test "analog/r912"
   test "analog/r913"
   test "analog/r922"
   test "analog/r936"
   test "analog/r937"
   test "analog/r1997"
!  test "analog/fanled01_f%led1"    ! Nostuff
!  test "analog/fanled01_f%led2"    ! Nostuff
!  test "analog/fanled23_f%led1"    ! Nostuff
!  test "analog/fanled23_f%led2"    ! Nostuff
!  test "analog/fanled45_f%led1"    ! Nostuff
!  test "analog/fanled45_f%led2"    ! Nostuff
   test "analog/ledm2%led1"
   test "analog/cr1%d1"
   test "analog/cr2%d1"
   test "analog/q5%q1"
   test "analog/q17%q1"
   test "analog/q19%q1"
   test "analog/q22%q1"
   test "analog/u11_cp_diode"
   test "analog/r246"                                   !remove for power up>>UNNAMED_20_OSC_I16_OE
!  test "analog/bcn_led%led1"                           ! Nostuff
!  test "analog/stat_led%led1"                          ! Nostuff
!  test "analog/stat_led%led2"                          ! Nostuff
!  test "analog/cr1_cp%d1"                              ! Nostuff
!  test "analog/cr1_f%d1"                               ! Nostuff
!  test "analog/cr2_a%d1"                               ! Nostuff
!  test "analog/cr2_f%d1"                               ! Nostuff
!  test "analog/cr3_a%d1"                               ! Nostuff
!  test "analog/cr3_f%d1"                               ! Nostuff
!  test "analog/cr4_f%d1"                               ! Nostuff
!  test "analog/cr5_f%d1"                               ! Nostuff
!  test "analog/cr6_f%d1"                               ! Nostuff
!  test "analog/cr7%d1"                                 ! Nostuff
!  test "analog/cr7_f%d1"                               ! Nostuff
!  test "analog/cr8%d1"                                 ! Nostuff
!  test "analog/cr8_f%d1"                               ! Nostuff
!  test "analog/cr9%d1"                                 ! Nostuff
!  test "analog/cr9_f%d1"                               ! Nostuff
!  test "analog/cr10%d1"                                ! Nostuff
!  test "analog/cr11%d1"                                ! Nostuff
!  test "analog/cr12%d1"                                ! Nostuff
!  test "analog/cr20%d1"                                ! Nostuff
!  test "analog/cr21%d1"                                ! Nostuff
!  test "analog/cr23_f%d1"                              ! Nostuff
!  test "analog/cr26%d1"                                ! Nostuff
!  test "analog/cr27%d1"                                ! Nostuff
!  test "analog/cr27_f%d1"                              ! Nostuff
!  test "analog/cr28%d1"                                ! Nostuff
!  test "analog/cr28_f%d1"                              ! Nostuff
!  test "analog/cr29%d1"                                ! Nostuff
!  test "analog/cr29_f%d1"                              ! Nostuff
!  test "analog/cr30%d1"                                ! Nostuff
!  test "analog/cr30_f%d1"                              ! Nostuff
!  test "analog/cr31%d1"                                ! Nostuff
!  test "analog/cr32%d1"                                ! Nostuff
!  test "analog/cr33%d1"                                ! Nostuff
!  test "analog/cr42%d1"                                ! Nostuff
!  test "analog/cr43%d1"                                ! Nostuff
!  test "analog/cr44%d1"                                ! Nostuff
!  test "analog/cr45%d1"                                ! Nostuff
!  test "analog/cr46%d1"                                ! Nostuff
!  test "analog/cr47%d1"                                ! Nostuff
!  test "analog/cr48%d1"                                ! Nostuff
!  test "analog/cr49%d1"                                ! Nostuff
!  test "analog/cr50%d1"                                ! Nostuff
!  test "analog/cr51%d1"                                ! Nostuff
!  test "analog/cr52%d1"                                ! Nostuff
!  test "analog/cr53%d1"                                ! Nostuff
!  test "analog/cr54%d1"                                ! Nostuff
!  test "analog/cr55%d1"                                ! Nostuff
!  test "analog/cr56%d1"                                ! Nostuff
!  test "analog/cr57%d1"                                ! Nostuff
!  test "analog/cr58%d11_8"                             ! Nostuff
!  test "analog/cr58%d12_7"                             ! Nostuff
!  test "analog/cr58%d13_6"                             ! Nostuff
!  test "analog/cr58%d14_5"                             ! Nostuff
!  test "analog/cr666_f%d1"                             ! Nostuff
!  test "analog/q1_f%q1"                                ! Nostuff
!  test "analog/q4_f%q1"                                ! Nostuff
!  test "analog/q666_f%q1"                              ! Nostuff
   unpowered
subend

sub VectorlessTest (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
 ! test "testjet"
subend

sub Polarity_Check (Status_Code, Message$)
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
subend

sub Connect_Check (Status_Code, Message$)
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
subend

sub Analog_Cluster_Tests (Status_Code, Message$)
global Status

    if Message$ <> "" then  print tab(5);Message$
    Status = Status_Code
   powered
   wait 500m
   test "analog/q1_cp"                                  ! NCH
   test "analog/q2_cp"                                  ! NCH
   test "analog/q3"                                     ! NCH
   test "analog/q4"                                     ! NCH
   test "analog/q4_cp"                                  ! NCH
   test "analog/q6"                                     ! NCH
   test "analog/q7"                                     ! NCH
   test "analog/q8"                                     ! PCH
   test "analog/q15"                                    ! NCH
   test "analog/q16"                                    ! NCH
   test "analog/q18"                                    ! NCH
   test "analog/q20"                                    ! NCH
   test "analog/q21"                                    ! NCH
   test "analog/q38"                                    ! NCH

!  test "analog/q2_f"                                   ! Nostuff
!  test "analog/q3_f"                                   ! Nostuff
!  test "analog/q5_f"                                   ! Nostuff
!  test "analog/q6_f"                                   ! Nostuff
!  test "analog/q7_f"                                   ! Nostuff
!  test "analog/q8_f"                                   ! Nostuff
!  test "analog/q23"                                    ! Nostuff
!  test "analog/q24"                                    ! Nostuff
   unpowered
subend

sub Verify_Grounds (Status_Code, Message$)
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
subend

sub Analog_Prepowered_Tests (Status_Code, Message$)
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
subend

sub Setup_Power_Supplies (Status_Code, Message$)
global Status
global Pslimit, Psgroup(*), True, False
global PMC_On

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
  faoff|wait 3
   powered
   wait 200m
   auxconnect 5
   wait 200m
   faoff
   wait 200m
   powered
   cps

!  auxconnect 5
!  wait 2
!  powered
!  cps


   gpconnect "FPGA_DBG_JMPR3" to "GND"
!  gpconnect "UNNAMED_20_OSC_I16_OE" to "GND"   !disable u19  !kill power
   gpconnect 20654 to 20655  !UNNAMED_16_MT25Q8P_I92_WPMVPPDQ2_CP to GND
   sps 2,12.00,2.00          !FAN power supplies
   wait 800m
   sps 3,12.00,2.00;optimize
   sps 4,12.10,2.00;optimize ! power supply increased due to parallel supply
   sps 7,12.10,2.00;optimize ! power supply increased due to parallel supply
   sps 8,12.10,2.00;optimize ! power supply increased due to parallel supply
   sps 11,12.10,2.00;optimize ! power supply increased due to parallel supply
   sps 12,12.10,2.00;optimize ! power supply increased due to parallel supply
   Pslimit = pslimit
   pass device
   Psgroup(1) = 3276     ! CCC (hex)
   Disabled = False
   for I = 1 to 1
      A = binand (Pslimit,Psgroup(I))
      if not bineor (A,Psgroup(I)) then
         if not Disabled then
            dps
            fail device
            Disabled = True
         end if
      else
         Pslimit = binand (Pslimit,bincmp(Psgroup(I)))
      end if
   next I
   if dutfailed then
      I = 1
      for Pscount = 1 to 12
         if binand (Pslimit,I) then
            report "Power Supply Number "
            report Pscount
            report "In Current Limit"
         end if
         I = 2*I
      next Pscount
      report "Power Supplies may be in parallel."
      report "________________________________________"
      report "Check for backwards"
      report "IC's or Capacitors."
      report "________________________________________"
   end if

   print tab(5);"Wait 35s for power up..."
   wait 45

     rps 3, V3, A3
     rps 4, V4, A4
     rps 7, V7, A7
     rps 8, V8, A8
     rps 11, V11, A11
     rps 12, V12, A12
     Amp = A3+A4+A7+A8+A11+A12
    print AMP

   test "analog/pwr_check"                    !for power rails check

   if PMC_On then
    ! Turn on PMC here
    ! spmc <Channel Id >,<Voltage Lower Limit>
    ! spmc reset
    ! spmc interrupt <on/off>
    ! rpmc <Channel Id>,<failure flag variable>
   end if
subend

sub Cycle_Power_On_Board
global PowerMsg$
global Failed_In_Power_Supplies
   call Disconnect_Power_On_Board
   call Setup_Power_Supplies (Failed_In_Power_Supplies, PowerMsg$)
subend

sub Disconnect_Power_On_Board
global PMC_On

   cps
   sps 2,0,0          !FAN power supplies
   sps 3,0,0;optimize
   sps 4,0,0;optimize  ! power supply increased due to parallel supply
   sps 7,0,0;optimize  ! power supply increased due to parallel supply
   sps 8,0,0;optimize  ! power supply increased due to parallel supply
   sps 11,0,0;optimize ! power supply increased due to parallel supply
   sps 12,0,0;optimize ! power supply increased due to parallel supply
   wait 1
   dps
   print tab(5); chr$(27)&"&v2S Doing discharge for board......"
   wait 5
   if PMC_On then
    ! Turn off PMC for all or selected channels here
    ! spmc <Channel Id> off
    ! spmc off
   end if
subend

sub BScan_Powered_Shorts_Tests (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
   call BScan_Disable_All_Chains
   if boardfailed then
      print "BScan disable failure; powered shorts tests skipped"
      subexit
   end if
  !test "digital/u5_cp_u5_cp_pch_ps"
  !test "digital/u5_cp_u5_cp_pch_dis"
subend

sub BScan_Interconnect_Tests (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
   safeguard cool
   call Tup("digital/u5_cp_u5_cp_pch_aio",15) !OK U5_CP_PCH Bypass
   call Tup("digital/u5_cp_u5_cp_pch",150)     !OK U5_CP_PCH Bypass
   call Tup("digital/u5_cp_u5_cp_pch_dis",15) !OK U5_CP_PCH Bypass
   call Tup("digital/u11_u11_dis",15)         !OK Test Integrity and IDCODE Only
subend

sub BScan_Incircuit_Tests (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
   safeguard cool

   call Tup("digital/u5_cp_connect_a",5)    ! OK
   call Tup("digital/u5_cp_connect_b",5)    ! OK
   call Tup("digital/u5_cp_connect_c",5)    ! OK
   call Tup("digital/u5_cp_connect_d",5)    ! OK
   call Tup("digital/u5_cp_connect_e",5)    ! OK
   call Tup("digital/u5_cp_connect_f",5)    ! OK
   call Tup("digital/u5_cp_connect_g",5)    ! OK
   call Tup("digital/u5_cp_connect_h",5)    ! OK
   call Tup("digital/u5_cp_connect_i",5)    ! OK
   call Tup("digital/u5_cp_connect_k",50)    ! OK
   call Tup("digital/u5_cp_connect_l",5)    ! OK
   call Tup("digital/u5_cp_connect_m",5)    ! OK
   call Tup("digital/u5_cp_connect_n",5)    ! OK
   call Tup("digital/u5_cp_connect_o",5)    ! OK
   call Tup("digital/u5_cp_connect_p",5)    ! OK
   call Tup("digital/u5_cp_connect_q",5)    ! OK
   call Tup("digital/u5_cp_connect_s",5)    ! OK
!~ call Tup("digital/u5_cp_connect_r",5)    !Hold one logic

!  *************************************!=======================!
!@ test "digital/u5_cp_pch_connect_a"   !  U5_PCH Extest Will   !
!@ test "digital/u5_cp_pch_connect_b"   !  Kill the Power Rails !
!@ test "digital/u5_cp_pch_connect_c"   !=======================!
!@ test "digital/u11_connect_a"         !Trip the power sequence!
!@ test "digital/u11_connect_b"         !TJ test                !
!@ test "digital/u11_connect_c"         !                       !
!@ test "digital/u11_connect_d"         !=======================!
subend

sub BScan_Silicon_Nails_Tests (Status_Code, Message$)
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
!   call BScan_Disable_All_Chains
!   if boardfailed then
!      print "BScan disable failure; Silicon Nails tests skipped"
!      subexit
!   end if
subend

sub Cover_Extend_Tests (Status_Code, Message$)
global Status

!   if Message$ <> "" then  print tab(5);Message$

!------------------------------------------------------------------------------
!print "Test Programmer Action Reminder:"
!print "Evaluate, act, and then delete this 'pause' section."

!pause ! Comment out pause and print statements above when evaluation complete.

!------------------------------------------------------------------------------
! This 'pause' section is placed here to remind the test programmer
! that the Cover-Extend tests must be debugged before they can
!
! When you have debugged the Cover-Extend test, you should
! comment out the print/pause statements above.
!------------------------------------------------------------------------------

!   Status = Status_Code
!   call BScan_Disable_All_Chains
!   if boardfailed then
!      print "BScan disable failure; Cover-Extend tests skipped"
!      subexit
!   end if
subend

sub BScan_Disable_All_Chains
!------------------------------------------------------------------------------
print "Test Programmer Action Reminder:"
print "Evaluate, act, and then delete this 'pause' section."

pause ! Comment out pause and print statements above when evaluation complete.

!------------------------------------------------------------------------------
! This 'pause' section is placed here to remind the test programmer
! that the Boundary-Scan disable tests depend upon their respective
! TCK/TMS signals being held in a stable state while other testing
! is done.  This assures that the disabled state of the Boundary-Scan
! chain is not accidentally lost.  Board level circuitry may
! interfere with the persistance of the disabled state.  You may
! need to take additional measures;  for example, you may place your
! own pullup/down resistor in the fixture to assure a stable TMS
! and/or TCK, or utilize a GP relay to disable some TCK oscillator, etc.
! For further explanation, see the Boundary-Scan Manual for the
! section titled 'Maintaining Persistance of Boundary-Scan Disables'.
!
! When you have assured persistance of the disable state, you should
! comment out the print/pause statements above.  It would also be a
! good idea to briefly document here the measures you may have taken
! (if any were needed) to assure persistance of the disables.
!------------------------------------------------------------------------------

   test "digital/u5_cp_u5_cp_pch_dis"
   test "digital/u11_u11_dis"
subend

sub Digital_Tests (Status_Code, Message$)
global Status,Act2_Vendor$,Act2_Program_Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
   safeguard cool
!@ test "digital/act2" !cover by act2 selection !OK    !AT90SO72        MCU
   call Tup("digital/u17",50)           !OK    !PI3B3253QE
!  test "digital/u24"                   !OK    ! 16Mb CG8782AT
   call Tup("digital/u1_3v3",50)        !OK    !TPS53915        VREG
   call Tup("digital/u1_cp",50)         !OK    !PI3B325         QSOP16
   call Tup("digital/u13",50)           !OK    !PI3B325         QSOP16
   call Tup("digital/u1_mvr",50)        !OK               ! IR35215 10000000
   call Tup("digital/u1_vr",50)         !OK               ! IR35215 10000000
   call Tup("digital/u22_cp",50)        !OK               ! NC7SV125P5X
   call Tup("digital/u25_cp",50)        !OK               ! SN74AUC1G125DCKR
   call Tup("digital/u26_cp",50)        !OK               ! SN74AUC1G125DCKR
   call Tup("digital/u27_cp",50)        !OK               ! SN74AUC1G125DCKR
   call Tup("digital/u33_cp",50)        !OK               ! 74AUC1G125DCKR
   call Tup("digital/u34_cp",50)        !OK               ! 74AUC1G125DCKR
   call Tup("digital/u20_cp",50)        !OK              ! 74AVC8T245PW
   call Tup("digital/u14_cp",50)        !OK              ! 74AVCH4T245PW
   call Tup("digital/u15_cp",50)        !OK              ! 74AVCH4T245PW
   call Tup("digital/u19_cp",50)        !OK              ! 74AVCH4T245PW
   call Tup("digital/u17_cp",50)        !OK              ! 74AVC8T245PW
   call Tup("digital/u18_cp",50)        !OK              ! 74AVC8T245PW
   call Tup("digital/u16_cp",50)        !OK              ! LSF0102DCT
   call Tup("digital/u32_cp",50)        !OK              ! LSF0102DCT
   call Tup("digital/u2_cp",50)         !OK              ! PI5A3157ZAEX

!@ detect u11_cp at analog/u11_cp_diode
!@ call Dual_test("digital/u11_cp","digital/u11_cp_new") !OK ! MT25QL128ABA1ESE
   test"digital/u12_cp"                 !OK              ! 74AVC1T45GW
   call Tup("digital/u13_cp",50)        !OK              ! PCA9617ADP
   call Tup("digital/u29",50)           !OK              ! PCA9617ADP
!@ test "digital/u14"!u14.pin2,3 short probe         ! ICS553MILF
   safeguard cool
   call Tup("digital/u30",50)           !OK              ! ADM1023ARQZ
   call Tup("digital/u21_cp",50)        !OK              ! 74LVC1G126SE
   call Tup("digital/u23",50)           !OK              ! BQ4802LYPW
   call Tup("digital/u3_cp",50)         !OK    !PI3B325         QSOP16
   call Tup("digital/u4_cp",50)         !OK              ! PI5A3157ZAEX
   call Tup("digital/u28_cp",50)        !OK              ! 74LVC1G07GW
   call Tup("digital/flshg_cp",50)      !OK    !N25Q128A13ESE4  PROG
   call Tup("digital/flshp_cp",50)      !OK    !N25Q128A13ESE4  PROG
   call Tup("digital/u7",50)            !OK  !drive H will kill power 20180731
   wait 2
   call Tup("digital/u22",50)           !OK  !drive H will kill power 20180731

!@ test "digital/u23_cp"            !74AUC1G            ! tck, use short probe
!@ test "digital/u24_cp"            !74AUC1G            ! tck, use short probe
!@ test "digital/u31_cp"            !74AUC1G            ! tck, use short probe
!@ test "digital/u21"               !OK                 ! 74LVC07APW
!   test "digital/u20"           !M25P64-VMF6TP  OK     ! PROG, use short probe
!  test "digital/u18"            !MTFC4GACAECN-1M       ! eMMC TJ only
!  test "digital/fanctrl01_f"                           ! Nostuff
!  test "digital/fanctrl23_f"                           ! Nostuff
!  test "digital/fanctrl45_f"                           ! Nostuff
!  test "digital/u1_f"                                  ! Nostuff
!  test "digital/u15"                                   ! Nostuff
!  test "digital/u26"                                   ! Nostuff
!  test "digital/u27"                                   ! Nostuff
!  test "digital/u28"                                   ! Nostuff
!  test "digital/u31"                                   ! Nostuff
!  test "digital/u32"                                   ! Nostuff
!  test "digital/u44_f"                                 ! Nostuff
!  test "digital/u666_f"                                ! Nostuff
!  test "digital/u4"                                    ! Nostuff
!  test "digital/u5"                                    ! Nostuff
!  test "digital/u6"                                    ! Nostuff
!  test "digital/u12"                                   ! Nostuff
!  test "digital/u100"                                  ! Nostuff
subend

sub Functional_Tests (Status_Code, Message$)
global Option
global Status,Act2EprPath$
global HDR1(*),HDR2(*),HDR3(*)
global EE_D1(*),EE_D2(*),EE_D3(*)
global XSUM1(*),XSUM2(*),XSUM3(*)
global EE_R1(*),EE_R2(*),EE_R3(*)
global Serial$,Board$,Board_Rev$,Act2_Vendor$,Act2_ch1,Act2_ch2,Act2_ch3

!*****SPROM COOKIE CHECKING*******     !1 Added for EEPROM compare
global Cookie_pass
Cookie_pass = 0
!*********************************
!!if Message$ <> "" then  print tab(5);Message$
  Status = Status_Code

  safeguard cool
  Start1 = msec  ! To evaluate test time for start of conversion
  call Convert_Serial_Number(Serial$)
  call EE_Setup_ACT2
  Start2 = msec   ! To evaluate test time for start of programming

  print "      Programming Data to ACT2"
  test Act2_Vendor$&"/act2%pro_p1";HDR1(*),EE_D1(*),XSUM1(*),EE_R1(*)|Act2_ch1 =1
  test Act2_Vendor$&"/act2%pro_p2";HDR2(*),EE_D2(*),XSUM2(*),EE_R2(*)|Act2_ch2 =1
  test Act2_Vendor$&"/act2%pro_p3";HDR3(*),EE_D3(*),XSUM3(*),EE_R3(*)|Act2_ch3 =1

 if dutfailed then
    report "      ACT2 Data Programming Failed."
    goto ACT2END
 end if
 Start3 = msec ! To evaluate test time for start of read/dump
   call Read_EEprom

 if boardfailed then
    report "      ACT2(!????? location) Data Read Failed."
    goto ACT2END
 end if

!!!!**********************************************************
! To evaluate test time for start of compare
Start4 = msec

! This is a Cisco Requirement have to implement in all project
    !*************EEPROM COOKIE CHECKING******************
!!@    if not dutfailed then Cookie_pass = Cookie_pass + 1

!!@Compare_result = 1
!!@copy Act2EprPath$&"\EE_Data_Hex_"&Serial$[1;11] over "EE_Data1_Hex"

!!@execute "sed -n '1,4p' EE_Data1_Hex > EE_read_Hex",Er; append
!!@execute "sed -n '7,57p' EE_Data1_Hex >> EE_read_Hex",Er; append
!!@execute "sed -n '66, 512p' EE_Data1_Hex >> EE_read_Hex",Er; append

! Create a master file for you project with the below naming convention
! Exclude variable data between two serial numbers
! Serial number, check sum

!????? need check the gold board hex read file name

!!@if Serial$[1;3] = "FLM" then
!!@execute "diff EE_master_Hex_18922_05_C0 EE_read_Hex",Compare_result;append
!!@else
!!@execute "diff EE_master_Hex_18922_05_C0_FDO EE_read_Hex",Compare_result;append
!!@end if
!!@  if Compare_result = 0 then Cookie_pass = Cookie_pass + 1

!!@   Status = Status_Code

! This is a Cisco Requirement have to implement in all project
!!@if Cookie_pass = 2 then
!!@   print tab(6),chr$(27)&"&v2S PCAMAP Programming and Compare Passed"
!!@   else
!!@   print tab(6),chr$(27)&"&v1S PCAMAP Programming and Compare failed"
!!@   print "      Call TECHNICIAN          "
!!@   print "      Serial Number: ";Serial$[1;11]

!!@   fail device

!!@   report ""
!!@   report " --------------------------------------"
!!@   report " PCAMAP Programming and Compare failed "
!!@   report " Serial Number: ";Serial$[1;11]
!!@   report " --------------------------------------"
!!@   report ""
!!@! Time delay for operator to see the failure message
!!@wait 2
!!@end if

! To evalute Test time for each section of the program subroutine
! uncomment the print stmt if needed to review the programming
Start5=msec
Result1 = (Start2-Start1)/1000
print "EEprom Programming Test Time with Conversion is "; Result1
Result1 = (Start3-Start2)/1000
print "EEprom Programming Test Time is "; Result1
Result1 = (Start4-Start3)/1000
print "EEprom Read/Dump Test Time is "; Result1
Result1 = (Start5-Start4)/1000
print "EEprom Compare with Master File Test Time is "; Result1
Result1 = (Start5-Start1)/1000
print "    Total Test Time for EEprom Program/Verify is ";(Result1);"secs"
ACT2END:

subend

sub Analog_Functional_Tests (Status_Code, Message$)
global Status

   if Message$ <> "" then  print tab(5);Message$
   Status = Status_Code
   safeguard cool
   test "analog/u1"              !OK!P0V6_VTT           ! VREG
   test "analog/u1_5v"           !OK!P5V,P1V7           ! VREG
   test "analog/u1_91_mvr"       !OK!P1V2_VDDQ          ! VREG
   test "analog/u1_91_vr"        !OK!PVCCIN             ! VREG
   test "analog/u1_92_vr"        !OK!PVCCIN             ! VREG
   test "analog/u1_98_mvr"       !OK!P1V05C             ! VREG
   test "analog/u1_adv"          !OK!P1_2VA,P3_3VA      ! VREG
   test "analog/u1_vpp"          !OK!VCCSUS3_3,DDR4_VPP ! VREG
   test "analog/u2"              !OK!P1V3               ! LINEAR
   test "analog/u2_adv"          !OK!P2_5VA             ! VREG
   test "analog/u25"             !OK!P1V5_PCH           ! LINEAR
   test "analog/u150"            !OK!P1V8               ! VREG-LDO

!@ ----- CLOCK DIVIDER ------
!@ sps 5,5.00,1.00;optimize
!@ test "analog/u19%freq"         !125M/80  !short probe for BS stable
!@ test "mixed/fanhs01_f"                               ! Nostuff
!@ test "mixed/fanhs23_f"                               ! Nostuff
!@ test "mixed/fanhs45_f"                               ! Nostuff
!@ test "analog/u1_p1v2_a"                              ! Nostuff
!@ test "analog/u1_p2v5_a"                              ! Nostuff
!@ test "analog/y1"                                     ! 32.768kHz
!@ test "analog/y1_cp"                                  ! 32.768kHz
!@ test "analog/y2_cp"                                  ! 25.000MHz
!@ test "analog/y3_cp"                                  ! 25.000MHz
subend

sub Program_Flash (Device$, Status_Code, Message$)
global Status
global Report_level$, Logging

  if Device$ = "" then  subexit
  if Message$ <> "" then  print tab(5);Message$
  Status = Status_Code

  ! Verify Manufacturer ID and device ID codes.
  ! The ID test should be executed in digital for ICT purposes.
  test "digital/" & Device$ & "%id"
  if dutfailed then
    print tab(15); Device$; " : Device ID failed"
    subexit ! if the wrong device is installed, exit the program subroutine
  end if

  !remove reporting and logging while verifying device status
  Report_level$ = rli$
  report level is none
  if Logging then
    log level is all  !log level is non  !changed by tool
  end if
  print tab(8); "Verifying Status"
  safeguard none  !flash! This board meets design for On-Board Programming
                  !       criteria for safeguard none to be safe
                  !       Programming runs very slowly with safeguard on

  !flash! Comment the appropriate crc test(s) in Digital_Tests subroutine
  test "digital/" & Device$ & "%crc"
  if not dutfailed then
    print tab(15); Device$; " : Device pre-programmed"
    call Cleanup_Flash
    subexit  ! the device is already properly programmed, exit subroutine
  else
    pass device  ! clears dutfailed, boardfailed if only failure
    print tab(15); Device$; " : Contains incorrect data"
  end if

  ! Verify device is blank.
  !flash! Comment the appropriate blank test(s) in Digital_Tests subroutine
  test "digital/" & Device$ & "%blank"
  if dutfailed then
    pass device  ! clears dutfailed, boardfailed if only failure
    print tab(15); Device$; " : Not blank"
    print tab(8); "Erasing"
    !flash! call Setup_Power_Supplies_Program  ! add any necessary programming
                                               ! voltages to a new subroutine
    !flash! Comment the appropriate erase test(s) in Digital_Tests subroutine
    test "digital/" & Device$ & "%erase"
    if not dutfailed then
      print tab(8); "Erase complete"
    end if
  end if
  ! Some older devices may need two erase sequences. If erase fails
  ! twice on only one board, continue to program all. The final CRC
  ! check will determine the viability of the erase program sequence

  if dutfailed then
    pass device  ! clears dutfailed, boardfailed if only failure
    print tab(15); Device$; " : Needed to be erased twice"
    test "digital/" & Device$ & "%erase"
    if dutfailed then
      call Cleanup_Flash   !flash! move above erase test if full report
                           !       of failing erase tests is desired
      print tab(15); Device$; " : Erase Failed"
      subexit  ! if the device cannot be erased
    end if          !if dutfailed second erase
    print tab(8); "Erase complete"
  end if            !if dutfailed first erase
  print tab(8); "Programming"
  A=msec
  !flash! Comment the appropriate program test(s) in Digital_Tests subroutine
  test "digital/" & Device$ & "%program"
  B = (msec-A)/1000
  if not dutfailed then
    print tab(15); "Programming complete in"; B;" seconds"
  else
    print tab(15); "Programming Failed"
    pass device
  end if
  !flash! call Setup_Power_Supplies (Failed_In_Power_Supplies, PowerMsg$)
  !flash! if dutfailed then
  !flash!   print "Power supplies limited"
  !flash!   call Cleanup_Flash
  !flash!   subexit
  !flash! end if
  call Cleanup_Flash  !flash! move above program test for full reporting
  print tab(8); "Verifying Data"
  !flash! Comment the appropriate crc test(s) in Digital_Tests subroutine
  test "digital/" & Device$ & "%crc"
  if dutfailed then
    print tab(15); Device$; " : Contains incorrect data"
  else
    print tab(15); Device$; " : Contains correct data"
  end if
subend

def fnPinsfailed (Message$)

   if Message$ <> "" then  print tab(5);Message$
   Pins_failed_flag = 0
!  test "pins"
   if dutfailed then Pins_failed_flag = 1
   return Pins_failed_flag
fnend

sub ScanWorks_Setup
! CAUTION:  Within this subroutine, do NOT use testhead statements
! CAUTION:  with the exception of the following statements:
! CAUTION:  testhead cleanup, test scanworks, scanworks reset.
! CAUTION:  Failure to follow this guideline can result in damage
! CAUTION:  to the BSI card.
   testhead cleanup
subend

sub ScanWorks_Pretest
! CAUTION:  Within this subroutine, do NOT use testhead statements
! CAUTION:  with the exception of the following statements:
! CAUTION:  testhead cleanup, test scanworks, scanworks reset.
! CAUTION:  Failure to follow this guideline can result in damage
! CAUTION:  to the BSI card.
global Status, Failed_In_SW_Testing

!   Status = Failed_In_SW_Testing
!   call ScanWorks_Setup
!   call ScanWorks_Cleanup
subend

sub ScanWorks_Cleanup
! CAUTION:  Within this subroutine, do NOT use testhead statements
! CAUTION:  with the exception of the following statements:
! CAUTION:  testhead cleanup, test scanworks, scanworks reset.
! CAUTION:  Failure to follow this guideline can result in damage
! CAUTION:  to the BSI card.
   scanworks reset
subend

sub ScanWorks_Scan_Path_Verify_Tests (Status_Code, Message$)
! CAUTION:  Within this subroutine, do NOT use testhead statements
! CAUTION:  with the exception of the following statements:
! CAUTION:  testhead cleanup, test scanworks, scanworks reset.
! CAUTION:  Failure to follow this guideline can result in damage
! CAUTION:  to the BSI card.
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
!   call ScanWorks_Setup
!   call ScanWorks_Cleanup
subend

sub ScanWorks_Interconnect_Tests (Status_Code, Message$)
! CAUTION:  Within this subroutine, do NOT use testhead statements
! CAUTION:  with the exception of the following statements:
! CAUTION:  testhead cleanup, test scanworks, scanworks reset.
! CAUTION:  Failure to follow this guideline can result in damage
! CAUTION:  to the BSI card.
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
!   call ScanWorks_Setup
!   call ScanWorks_Cleanup
subend

sub ScanWorks_Mem_Interconnect_Tests (Status_Code, Message$)
! CAUTION:  Within this subroutine, do NOT use testhead statements
! CAUTION:  with the exception of the following statements:
! CAUTION:  testhead cleanup, test scanworks, scanworks reset.
! CAUTION:  Failure to follow this guideline can result in damage
! CAUTION:  to the BSI card.
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
!   call ScanWorks_Setup
!   call ScanWorks_Cleanup
subend

sub ScanWorks_Cluster_Tests (Status_Code, Message$)
! CAUTION:  Within this subroutine, do NOT use testhead statements
! CAUTION:  with the exception of the following statements:
! CAUTION:  testhead cleanup, test scanworks, scanworks reset.
! CAUTION:  Failure to follow this guideline can result in damage
! CAUTION:  to the BSI card.
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
!   call ScanWorks_Setup
!   call ScanWorks_Cleanup
subend

sub ScanWorks_Mem_BIST (Status_Code, Message$)
! CAUTION:  Within this subroutine, do NOT use testhead statements
! CAUTION:  with the exception of the following statements:
! CAUTION:  testhead cleanup, test scanworks, scanworks reset.
! CAUTION:  Failure to follow this guideline can result in damage
! CAUTION:  to the BSI card.
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
!   call ScanWorks_Setup
!   call ScanWorks_Cleanup
subend

sub ScanWorks_Device_Programming (Status_Code, Message$)
! CAUTION:  Within this subroutine, do NOT use testhead statements
! CAUTION:  with the exception of the following statements:
! CAUTION:  testhead cleanup, test scanworks, scanworks reset.
! CAUTION:  Failure to follow this guideline can result in damage
! CAUTION:  to the BSI card.
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
!   call ScanWorks_Setup
!   call ScanWorks_Cleanup
subend

sub ScanWorks_Flash_Programming (Status_Code, Message$)
! CAUTION:  Within this subroutine, do NOT use testhead statements
! CAUTION:  with the exception of the following statements:
! CAUTION:  testhead cleanup, test scanworks, scanworks reset.
! CAUTION:  Failure to follow this guideline can result in damage
! CAUTION:  to the BSI card.
global Status

!   if Message$ <> "" then  print tab(5);Message$
!   Status = Status_Code
!   call ScanWorks_Setup
!   call ScanWorks_Cleanup
subend

! End of Testplan Writer Generated Testplan.

sub Commented  !TTR!

!   test "analog/c1"                                     ! Nostuff !Pre_Shorts
!   test "analog/c1_cp"                                  ! Nostuff !Pre_Shorts
!   test "analog/c1_f"                                   ! Nostuff !Pre_Shorts
!   test "analog/c1_p1v2_a"                              ! Nostuff !Pre_Shorts
!   test "analog/c2"                                     ! Nostuff !Pre_Shorts
!   test "analog/c2_f"                                   ! Nostuff !Pre_Shorts
!   test "analog/c2_p2v5_a"                              ! Nostuff !Pre_Shorts
!   test "analog/c3_f"                                   ! Nostuff !Pre_Shorts
!   test "analog/c3_p1v2_a"                              ! Nostuff !Pre_Shorts
!   test "analog/c3_p2v5_a"                              ! Nostuff !Pre_Shorts
!   test "analog/c4"                                     ! Nostuff !Pre_Shorts
!   test "analog/c4_f"                                   ! Nostuff !Pre_Shorts
!   test "analog/c4_p1v2_a"                              ! Nostuff !Pre_Shorts
!   test "analog/c4_p2v5_a"                              ! Nostuff !Pre_Shorts
!   test "analog/c5"                                     ! Nostuff !Pre_Shorts
!   test "analog/c5_f"                                   ! Nostuff !Pre_Shorts
!   test "analog/c5_p1v2_a"                              ! Nostuff !Pre_Shorts
!   test "analog/c6_f"                                   ! Nostuff !Pre_Shorts
!   test "analog/c7_f"                                   ! Nostuff !Pre_Shorts
!   test "analog/c8"                                     ! Nostuff !Pre_Shorts
!   test "analog/c8_f"                                   ! Nostuff !Pre_Shorts
!   test "analog/c9"                                     ! Nostuff !Pre_Shorts
!   test "analog/c9_f"                                   ! Nostuff !Pre_Shorts
!   test "analog/c10"                                    ! Nostuff !Pre_Shorts
!   test "analog/c10_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c11"                                    ! Nostuff !Pre_Shorts
!   test "analog/c11_adv"                                ! Nostuff !Pre_Shorts
!   test "analog/c12_5v"                                 ! Nostuff !Pre_Shorts
!   test "analog/c12_adv"                                ! Nostuff !Pre_Shorts
!   test "analog/c12_vpp"                                ! Nostuff !Pre_Shorts
!   test "analog/c13_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c14_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c15_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c16_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c17_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c18_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c19_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c20_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c21_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c22_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c23_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c24_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c25_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c26_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c29_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c30_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c32"                                    ! Nostuff !Pre_Shorts
!   test "analog/c33"                                    ! Nostuff !Pre_Shorts
!   test "analog/c33_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c34"                                    ! Nostuff !Pre_Shorts
!   test "analog/c34_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c35"                                    ! Nostuff !Pre_Shorts
!   test "analog/c41_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c43_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c44_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c45_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c46_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c47_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c52"                                    ! Nostuff !Pre_Shorts
!   test "analog/c53"                                    ! Nostuff !Pre_Shorts
!   test "analog/c53_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c54"                                    ! Nostuff !Pre_Shorts
!   test "analog/c55"                                    ! Nostuff !Pre_Shorts
!   test "analog/c59"                                    ! Nostuff !Pre_Shorts
!   test "analog/c60"                                    ! Nostuff !Pre_Shorts
!   test "analog/c95_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c96_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c97_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c98_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c99_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/c100_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/c101_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/c140_cp"                                ! Nostuff !Pre_Shorts
!   test "analog/c239"                                   ! Nostuff !Pre_Shorts
!   test "analog/c270"                                   ! Nostuff !Pre_Shorts
!   test "analog/l1_p1v2_a"                              ! Nostuff !Pre_Shorts
!   test "analog/r1"                                     ! Nostuff !Pre_Shorts
!   test "analog/r1_cp"                                  ! Nostuff !Pre_Shorts
!   test "analog/r1_f"                                   ! Nostuff !Pre_Shorts
!   test "analog/r1_p1v2_a"                              ! Nostuff !Pre_Shorts
!   test "analog/r1_p2v5_a"                              ! Nostuff !Pre_Shorts
!   test "analog/r2_91_mvr"                              ! Nostuff !Pre_Shorts
!   test "analog/r2_91_vr"                               ! Nostuff !Pre_Shorts
!   test "analog/r2_92_vr"                               ! Nostuff !Pre_Shorts
!   test "analog/r2_98_mvr"                              ! Nostuff !Pre_Shorts
!   test "analog/r2_f"                                   ! Nostuff !Pre_Shorts
!   test "analog/r3_cp"                                  ! Nostuff !Pre_Shorts
!   test "analog/r3_f"                                   ! Nostuff !Pre_Shorts
!   test "analog/r3_p2v5_a"                              ! Nostuff !Pre_Shorts
!   test "analog/r4_cp"                                  ! Nostuff !Pre_Shorts
!   test "analog/r4_f"                                   ! Nostuff !Pre_Shorts
!   test "analog/r4_p1v2_a"                              ! Nostuff !Pre_Shorts
!   test "analog/r5_cp"                                  ! Nostuff !Pre_Shorts
!   test "analog/r5_f"                                   ! Nostuff !Pre_Shorts
!   test "analog/r5_p1v2_a"                              ! Nostuff !Pre_Shorts
!   test "analog/r6_cp"                                  ! Nostuff !Pre_Shorts
!   test "analog/r6_f"                                   ! Nostuff !Pre_Shorts
!   test "analog/r7_cp"                                  ! Nostuff !Pre_Shorts
!   test "analog/r7_f"                                   ! Nostuff !Pre_Shorts
!   test "analog/r07_mvr"                                ! Nostuff !Pre_Shorts
!   test "analog/r07_vr"                                 ! Nostuff !Pre_Shorts
!   test "analog/r8"                                     ! Nostuff !Pre_Shorts
!   test "analog/r8_cp"                                  ! Nostuff !Pre_Shorts
!   test "analog/r8_f"                                   ! Nostuff !Pre_Shorts
!   test "analog/r8_p1v2_a"                              ! Nostuff !Pre_Shorts
!   test "analog/r08_mvr"                                ! Nostuff !Pre_Shorts
!   test "analog/r08_vr"                                 ! Nostuff !Pre_Shorts
!   test "analog/r9"                                     ! Nostuff !Pre_Shorts
!   test "analog/r9_cp"                                  ! Nostuff !Pre_Shorts
!   test "analog/r9_f"                                   ! Nostuff !Pre_Shorts
!   test "analog/r10"                                    ! Nostuff !Pre_Shorts
!   test "analog/r10_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r10_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r11_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r11_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r12_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r12_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r13_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r13_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r14_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r14_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r15_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r15_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r16_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r16_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r17"                                    ! Nostuff !Pre_Shorts
!   test "analog/r17_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r17_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r18"                                    ! Nostuff !Pre_Shorts
!   test "analog/r18_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r18_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r19"                                    ! Nostuff !Pre_Shorts
!   test "analog/r19_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r19_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r20"                                    ! Nostuff !Pre_Shorts
!   test "analog/r20_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r20_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r21"                                    ! Nostuff !Pre_Shorts
!   test "analog/r21_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r21_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r22"                                    ! Nostuff !Pre_Shorts
!   test "analog/r22_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r22_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r23"                                    ! Nostuff !Pre_Shorts
!   test "analog/r23_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r23_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r24"                                    ! Nostuff !Pre_Shorts
!   test "analog/r24_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r24_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r25"                                    ! Nostuff !Pre_Shorts
!   test "analog/r25_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r25_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r26"                                    ! Nostuff !Pre_Shorts
!   test "analog/r26_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r26_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r27"                                    ! Nostuff !Pre_Shorts
!   test "analog/r27_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r27_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r27_mvr"                                ! Nostuff !Pre_Shorts
!   test "analog/r27_vr"                                 ! Nostuff !Pre_Shorts
!   test "analog/r28_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r28_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r29_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r29_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r30_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r30_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r31_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r31_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r32_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r32_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r33"                                    ! Nostuff !Pre_Shorts
!   test "analog/r33_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r33_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r34_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r34_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r35_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r36_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r36_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r37_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r37_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r38"                                    ! Nostuff !Pre_Shorts
!   test "analog/r38_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r38_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r39"                                    ! Nostuff !Pre_Shorts
!   test "analog/r39_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r39_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r40_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r40_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r41_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r41_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r42_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r42_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r43_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r44_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r44_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r45_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r46_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r46_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r47_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r47_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r48_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r48_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r49_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r49_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r50_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r50_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r51_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r51_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r52_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r52_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r53_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r53_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r54_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r54_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r55_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r55_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r56_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r56_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r57_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r57_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r58_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r58_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r59_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r59_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r60_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r60_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r61_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r61_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r62_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r62_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r63_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r63_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r64_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r64_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r65_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r65_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r66_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r66_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r67_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r67_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r68_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r69_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r69_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r70_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r70_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r71_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r72_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r72_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r73_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r73_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r74_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r74_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r75_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r75_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r76_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r76_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r77_cp"                                 ! Nostuff !Pre_Shorts
!   test "analog/r77_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r78_f"                                  ! Nostuff !Pre_Shorts
!   test "analog/r79_mvr"                                ! Nostuff !Pre_Shorts
!   test "analog/r79_vr"                                 ! Nostuff !Pre_Shorts
!   test "analog/r86_mvr"                                ! Nostuff !Pre_Shorts
!   test "analog/r86_vr"                                 ! Nostuff !Pre_Shorts
!   test "analog/r87_mvr"                                ! Nostuff !Pre_Shorts
!   test "analog/r119"                                   ! Nostuff !Pre_Shorts
!   test "analog/r120"                                   ! Nostuff !Pre_Shorts
!   test "analog/r121"                                   ! Nostuff !Pre_Shorts
!   test "analog/r122"                                   ! Nostuff !Pre_Shorts
!   test "analog/r123"                                   ! Nostuff !Pre_Shorts
!   test "analog/r124"                                   ! Nostuff !Pre_Shorts
!   test "analog/r125"                                   ! Nostuff !Pre_Shorts
!   test "analog/r126"                                   ! Nostuff !Pre_Shorts
!   test "analog/r127"                                   ! Nostuff !Pre_Shorts
!   test "analog/r128"                                   ! Nostuff !Pre_Shorts
!   test "analog/r129"                                   ! Nostuff !Pre_Shorts
!   test "analog/r130"                                   ! Nostuff !Pre_Shorts
!   test "analog/r131"                                   ! Nostuff !Pre_Shorts
!   test "analog/r131_cp"                                ! Nostuff !Pre_Shorts
!   test "analog/r132"                                   ! Nostuff !Pre_Shorts
!   test "analog/r132_cp"                                ! Nostuff !Pre_Shorts
!   test "analog/r133"                                   ! Nostuff !Pre_Shorts
!   test "analog/r134"                                   ! Nostuff !Pre_Shorts
!   test "analog/r155_cp"                                ! Nostuff !Pre_Shorts
!   test "analog/r156_cp"                                ! Nostuff !Pre_Shorts
!   test "analog/r157_cp"                                ! Nostuff !Pre_Shorts
!   test "analog/r162_cp"                                ! Nostuff !Pre_Shorts
!   test "analog/r169"                                   ! Nostuff !Pre_Shorts
!   test "analog/r176_cp"                                ! Nostuff !Pre_Shorts
!   test "analog/r181"                                   ! Nostuff !Pre_Shorts
!   test "analog/r185"                                   ! Nostuff !Pre_Shorts
!   test "analog/r186"                                   ! Nostuff !Pre_Shorts
!   test "analog/r195_cp"                                ! Nostuff !Pre_Shorts
!   test "analog/r201"                                   ! Nostuff !Pre_Shorts
!   test "analog/r202"                                   ! Nostuff !Pre_Shorts
!   test "analog/r203"                                   ! Nostuff !Pre_Shorts
!   test "analog/r204"                                   ! Nostuff !Pre_Shorts
!   test "analog/r220"                                   ! Nostuff !Pre_Shorts
!   test "analog/r230"                                   ! Nostuff !Pre_Shorts
!   test "analog/r247"                                   ! Nostuff !Pre_Shorts
!   test "analog/r248"                                   ! Nostuff !Pre_Shorts
!   test "analog/r249"                                   ! Nostuff !Pre_Shorts
!   test "analog/r250"                                   ! Nostuff !Pre_Shorts
!   test "analog/r251"                                   ! Nostuff !Pre_Shorts
!   test "analog/r252"                                   ! Nostuff !Pre_Shorts
!   test "analog/r253"                                   ! Nostuff !Pre_Shorts
!   test "analog/r254"                                   ! Nostuff !Pre_Shorts
!   test "analog/r257_a"                                 ! Nostuff !Pre_Shorts
!   test "analog/r258_a"                                 ! Nostuff !Pre_Shorts
!   test "analog/r262"                                   ! Nostuff !Pre_Shorts
!   test "analog/r263"                                   ! Nostuff !Pre_Shorts
!   test "analog/r264"                                   ! Nostuff !Pre_Shorts
!   test "analog/r265"                                   ! Nostuff !Pre_Shorts
!   test "analog/r266"                                   ! Nostuff !Pre_Shorts
!   test "analog/r267"                                   ! Nostuff !Pre_Shorts
!   test "analog/r268"                                   ! Nostuff !Pre_Shorts
!   test "analog/r269"                                   ! Nostuff !Pre_Shorts
!   test "analog/r281_cp"                                ! Nostuff !Pre_Shorts
!   test "analog/r289_cp"                                ! Nostuff !Pre_Shorts
!   test "analog/r324"                                   ! Nostuff !Pre_Shorts
!   test "analog/r327"                                   ! Nostuff !Pre_Shorts
!   test "analog/r327_cp"                                ! Nostuff !Pre_Shorts
!   test "analog/r333"                                   ! Nostuff !Pre_Shorts
!   test "analog/r337_cp"                                ! Nostuff !Pre_Shorts
!   test "analog/r340_cp"                                ! Nostuff !Pre_Shorts
!   test "analog/r347_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r348_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r349_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r350_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r351_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r354_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r357_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r358_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r361"                                   ! Nostuff !Pre_Shorts
!   test "analog/r364"                                   ! Nostuff !Pre_Shorts
!   test "analog/r365"                                   ! Nostuff !Pre_Shorts
!   test "analog/r368"                                   ! Nostuff !Pre_Shorts
!   test "analog/r369_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r370_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r371_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r372_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r373"                                   ! Nostuff !Pre_Shorts
!   test "analog/r374"                                   ! Nostuff !Pre_Shorts
!   test "analog/r374_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r375_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r378_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r379_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r380_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r381_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r382_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r383_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r384_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r385_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r386_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r387_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r388_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r389"                                   ! Nostuff !Pre_Shorts
!   test "analog/r389_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r390"                                   ! Nostuff !Pre_Shorts
!   test "analog/r390_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r391"                                   ! Nostuff !Pre_Shorts
!   test "analog/r391_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r392"                                   ! Nostuff !Pre_Shorts
!   test "analog/r392_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r393"                                   ! Nostuff !Pre_Shorts
!   test "analog/r393_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r394"                                   ! Nostuff !Pre_Shorts
!   test "analog/r394_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r395"                                   ! Nostuff !Pre_Shorts
!   test "analog/r395_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r396"                                   ! Nostuff !Pre_Shorts
!   test "analog/r396_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r397"                                   ! Nostuff !Pre_Shorts
!   test "analog/r397_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r398"                                   ! Nostuff !Pre_Shorts
!   test "analog/r398_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r399"                                   ! Nostuff !Pre_Shorts
!   test "analog/r399_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r400"                                   ! Nostuff !Pre_Shorts
!   test "analog/r401"                                   ! Nostuff !Pre_Shorts
!   test "analog/r402"                                   ! Nostuff !Pre_Shorts
!   test "analog/r403"                                   ! Nostuff !Pre_Shorts
!   test "analog/r404"                                   ! Nostuff !Pre_Shorts
!   test "analog/r405"                                   ! Nostuff !Pre_Shorts
!   test "analog/r406"                                   ! Nostuff !Pre_Shorts
!   test "analog/r407"                                   ! Nostuff !Pre_Shorts
!   test "analog/r408_cp"                                ! Nostuff !Pre_Shorts
!   test "analog/r410"                                   ! Nostuff !Pre_Shorts
!   test "analog/r411"                                   ! Nostuff !Pre_Shorts
!   test "analog/r412_cp"                                ! Nostuff !Pre_Shorts
!   test "analog/r413"                                   ! Nostuff !Pre_Shorts
!   test "analog/r414"                                   ! Nostuff !Pre_Shorts
!   test "analog/r415"                                   ! Nostuff !Pre_Shorts
!   test "analog/r416_cp"                                ! Nostuff !Pre_Shorts
!   test "analog/r429"                                   ! Nostuff !Pre_Shorts
!   test "analog/r430"                                   ! Nostuff !Pre_Shorts
!   test "analog/r430_cp"                                ! Nostuff !Pre_Shorts
!   test "analog/r431"                                   ! Nostuff !Pre_Shorts
!   test "analog/r432"                                   ! Nostuff !Pre_Shorts
!   test "analog/r432_cp"                                ! Nostuff !Pre_Shorts
!   test "analog/r434_cp"                                ! Nostuff !Pre_Shorts
!   test "analog/r436_cp"                                ! Nostuff !Pre_Shorts
!   test "analog/r444_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r458"                                   ! Nostuff !Pre_Shorts
!   test "analog/r459"                                   ! Nostuff !Pre_Shorts
!   test "analog/r463"                                   ! Nostuff !Pre_Shorts
!   test "analog/r464"                                   ! Nostuff !Pre_Shorts
!   test "analog/r465"                                   ! Nostuff !Pre_Shorts
!   test "analog/r466"                                   ! Nostuff !Pre_Shorts
!   test "analog/r467"                                   ! Nostuff !Pre_Shorts
!   test "analog/r468"                                   ! Nostuff !Pre_Shorts
!   test "analog/r469"                                   ! Nostuff !Pre_Shorts
!   test "analog/r470"                                   ! Nostuff !Pre_Shorts
!   test "analog/r473_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r476_f"                                 ! Nostuff !Pre_Shorts
!   test "analog/r505"                                   ! Nostuff !Pre_Shorts
!   test "analog/r512"                                   ! Nostuff !Pre_Shorts
!   test "analog/r528"                                   ! Nostuff !Pre_Shorts
!   test "analog/r532"                                   ! Nostuff !Pre_Shorts
!   test "analog/r534"                                   ! Nostuff !Pre_Shorts
!   test "analog/r537"                                   ! Nostuff !Pre_Shorts
!   test "analog/r538"                                   ! Nostuff !Pre_Shorts
!   test "analog/r540"                                   ! Nostuff !Pre_Shorts
!   test "analog/r542"                                   ! Nostuff !Pre_Shorts
!   test "analog/r543"                                   ! Nostuff !Pre_Shorts
!   test "analog/r550"                                   ! Nostuff !Pre_Shorts
!   test "analog/r551"                                   ! Nostuff !Pre_Shorts
!   test "analog/r552"                                   ! Nostuff !Pre_Shorts
!   test "analog/r553"                                   ! Nostuff !Pre_Shorts
!   test "analog/r651"                                   ! Nostuff !Pre_Shorts
!   test "analog/r662"                                   ! Nostuff !Pre_Shorts
!   test "analog/r663"                                   ! Nostuff !Pre_Shorts
!   test "analog/r826_a"                                 ! Nostuff !Pre_Shorts
!   test "analog/l1_5v"                                  !Pre_Shorts
!   test "analog/l1_adv"                                 !Pre_Shorts
!   test "analog/l1_cp"                                  !Pre_Shorts
!   test "analog/l1_vpp"                                 !Pre_Shorts
!   test "analog/l01_3v3"                                !Pre_Shorts
!   test "analog/l2_5v"                                  !Pre_Shorts
!   test "analog/l2_adv"                                 !Pre_Shorts
!   test "analog/l2_cp"                                  !Pre_Shorts
!   test "analog/l2_vpp"                                 !Pre_Shorts
!   test "analog/l5"                                     !Pre_Shorts
!   test "analog/l6"                                     !Pre_Shorts
!   test "analog/l7"                                     !Pre_Shorts
!   test "analog/l8"                                     !Pre_Shorts
!   test "analog/l9"                                     !Pre_Shorts
!   test "analog/l10"                                    !Pre_Shorts
!   test "analog/r1_3v3"                                 ! Zero Ohm !Pre_Shorts
!   test "analog/r2_3v3"                                 ! Zero Ohm !Pre_Shorts
!   test "analog/r02_mvr"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r3_3v3"                                 ! Zero Ohm !Pre_Shorts
!   test "analog/r3_91_mvr"                              ! Zero Ohm !Pre_Shorts
!   test "analog/r3_91_vr"                               ! Zero Ohm !Pre_Shorts
!   test "analog/r3_92_vr"                               ! Zero Ohm !Pre_Shorts
!   test "analog/r3_98_mvr"                              ! Zero Ohm !Pre_Shorts
!   test "analog/r4_91_mvr"                              ! Zero Ohm !Pre_Shorts
!   test "analog/r4_91_vr"                               ! Zero Ohm !Pre_Shorts
!   test "analog/r4_92_vr"                               ! Zero Ohm !Pre_Shorts
!   test "analog/r4_98_mvr"                              ! Zero Ohm !Pre_Shorts
!   test "analog/r04_mvr"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r04_vr"                                 ! Zero Ohm !Pre_Shorts
!   test "analog/r5_91_mvr"                              ! Zero Ohm !Pre_Shorts
!   test "analog/r5_91_vr"                               ! Zero Ohm !Pre_Shorts
!   test "analog/r5_92_vr"                               ! Zero Ohm !Pre_Shorts
!   test "analog/r5_98_mvr"                              ! Zero Ohm !Pre_Shorts
!   test "analog/r05_mvr"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r05_vr"                                 ! Zero Ohm !Pre_Shorts
!   test "analog/r06_mvr"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r26_mvr"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r28_mvr"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r28_vr"                                 ! Zero Ohm !Pre_Shorts
!   test "analog/r32"                                    ! Zero Ohm !Pre_Shorts
!   test "analog/r36"                                    ! Zero Ohm !Pre_Shorts
!   test "analog/r43"                                    ! Zero Ohm !Pre_Shorts
!   test "analog/r48"                                    ! Zero Ohm !Pre_Shorts
!   test "analog/r49"                                    ! Zero Ohm !Pre_Shorts
!   test "analog/r50"                                    ! Zero Ohm !Pre_Shorts
!   test "analog/r51"                                    ! Zero Ohm !Pre_Shorts
!   test "analog/r52"                                    ! Zero Ohm !Pre_Shorts
!   test "analog/r53"                                    ! Zero Ohm !Pre_Shorts
!   test "analog/r54"                                    ! Zero Ohm !Pre_Shorts
!   test "analog/r55"                                    ! Zero Ohm !Pre_Shorts
!   test "analog/r79_91_mvr"                             ! Zero Ohm !Pre_Shorts
!   test "analog/r79_91_vr"                              ! Zero Ohm !Pre_Shorts
!   test "analog/r79_92_vr"                              ! Zero Ohm !Pre_Shorts
!   test "analog/r79_98_mvr"                             ! Zero Ohm !Pre_Shorts
!   test "analog/r93_cp"                                 ! Zero Ohm !Pre_Shorts
!   test "analog/r135"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r136"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r137"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r137_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r138"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r139"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r140"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r141"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r142"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r143"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r144"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r157"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r158"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r161"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r164"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r165"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r166"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r167"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r168"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r170"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r173_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r205"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r206"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r208"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r209"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r219_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r223_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r236"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r237"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r238"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r239"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r242"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r260"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r261_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r264_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r271"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r272"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r273"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r274"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r275"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r280"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r281"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r282"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r290"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r293_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r313_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r330_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r335_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r336"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r337"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r338_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r339_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r340"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r341"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r341_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r342_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r345_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r346_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r347_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r348_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r349_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r355"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r357_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r363"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r376"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r379"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r396_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r400_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r403_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r404_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r418_cp"                                ! Zero Ohm !Pre_Shorts
!   test "analog/r428"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r439"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r440"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r441"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r442"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r443"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r450"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r479"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r480"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r481"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r482"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r527"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r535"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r536"                                   ! Zero Ohm !Pre_Shorts
!   test "analog/r650"                                   ! Zero Ohm !Pre_Shorts
subend

sub Convert_Serial_Number(Serial$)
global Option, Mem_Table(*)
dim Test(1:20)

! Store Serial # to Memory Table
! Check for NULL Character

!! Serial$ = "FDO20370Q1M" !!For debug
 Serial$ = Serial$ &"\\\\\\\\\"
!print Serial$
 for Z = 1 to 10
     if num(Serial$[(2*Z-1);1]) = 92 then
          Test(2*Z-1) = 0  ! Odd order 1,3,5,7,..19
       else
          Test(2*Z-1) = shift(num(Serial$[(2*Z-1);1]), -8)
     end if
     if num(Serial$[2*Z;1]) = 92 then    ! reset "\" to "0" null
          Test(2*Z) = 0  ! Even order 2,4,6,8,..20
       else
          Test(2*Z) = num(Serial$[2*Z;1])
     end if
 next Z

 for J = 1 to 10
      Mem_Table(26+J) = Test(2*J-1) + Test(2*J) ! Mem_Table(27-36)
 next J

subend


sub EE_Setup_ACT2

global Serializing, Serial_Num_Writing
global EE_D1(*),EE_R1(*)
global EE_D2(*),EE_R2(*)
global EE_D3(*),EE_R3(*)
global HDR1(*),HDR2(*),HDR3(*)
global XSUM1(*),XSUM2(*),XSUM3(*)
global Mem_Table(*)
global Read_Data(*)
global Option ,Board$, Board_Rev$
global Assembly$,Green$,Red$
global Check_EEPROM,True,False,Serial$
global Board_BOM$
dim Header1(0:15),Header2(0:15),Header3(0:15)
dim Test(1:20)
dim Mac_Temp$(1:20)
!Board_Rev$ = "A0"
!~print Board_Rev$
!################################################################### #####!
!** SPROM COMMON BLOCK                                                   !
!** BLOCK 1  in WORD = (16 bits)                                         !
!################################################################### #####!
  print ""
  print tab(5); "IDEPROM PROGRAM VERSION"
  print tab(5); "-----------------------"

  Block_sig_0_1 = hti("ABAB") ! Hex           ! Byte 00-01 ! Address 0

  Block_ver1 = 3     ! Dec                    ! Byte 02    ! Address 1
  Block_len1 = 160   ! Dec                    ! Byte 03    ! Address 1

  Block_ver_len_2_3 = shift(Block_ver1,-8) + Block_len1

  Check_sum_4_5   = 0    ! Dec                ! Byte 04-05 ! Address 2
  Eprom_size_6_7  = 65535 ! Dec               ! Byte 06-07 ! Address 3
  Block_count_8_9 = 3    ! Dec                ! Byte 08-09 ! Address 4

!!====================================================== ======
!* FRU CODE : FABRIC
!!====================================================== ======
  Fru_maj_10_11 = hti("6002")  ! Hex          ! Byte 0A-0B ! Address 5
  Fru_min_12_13 = hti("0000")  ! Hex          ! Byte 0C-0D ! Address 6

!!====================================================== ======
!* OEM String : Fixed "Cisco Systems"
!!====================================================== ======
  OEM_Str$ = "Cisco Systems, Inc."            ! Byte 0E-21 ! Address 7 - 16
  call Chklength_S(OEM_Str$,20)

!!====================================================== ======
!! Product Number
!!====================================================== ======
  Prod_Num$ = "PINEDROPS"                     ! Byte 22-35 ! Addres 17- 26
  Product$ = Prod_Num$
  print tab(5); "Product Number: "; Prod_Num$
  call Chklength_S(Prod_Num$,20)

!!------------------------------------------------------------
!! Serial Number
!! Mem_Table(27-36)  ! Generated at Serial Routine
!!====================================================== ========
!  Serial$ = "FOC12345678"                    ! Byte 36-49 ! Addres 27- 36

!!====================================================== ======
!! Board Part Number ! Reset = 0 ! Ex.73-18922-04 => 73/18922/03
!!====================================================== ======
  Part_N_74_89$     = Board$                 ! Byte 4A-59 ! Address 37-44
  print tab(5); "Part Number: "; Part_N_74_89$
  call Chklength_S(Part_N_74_89$,16)

!!====================================================== ======
!! Part Number Revision
!!====================================================== ======
  Part_R_90_93$  = Board_Rev$  !             ! Byte 5A-5D ! Address 45
  print tab(5); "Part Number Revision: "; Part_R_90_93$
  call Chklength_S(Part_R_90_93$,4)

!! Mfg Deviation !
!!====================================================== ======
  Mfg_Dev_94_113$ = "00000000000000000000"    ! Byte 5E-71 ! Address 47-56
  call Chklength_S(Mfg_Dev_94_113$,20)

!!====================================================== ======
!! Hardware Version ! Reset = 0
!!====================================================== ======

  Hw_Rev_maj_114_115 = 2      !high byte   ! Byte 72-73 ! Address 57
  Hw_Rev_min_116_117 = 0      !low byte    ! Byte 74-75 ! Address 58

  print tab(5); "Hardware Version: ";val$(Hw_Rev_maj_114_115); ".";  val$(Hw_Rev_min_116_117)

!!====================================================== ======
!! Manufacturing Bits
!!====================================================== ======
  Mfg_bits_118_119 = 0                        ! Byte 76-77 ! Address 59

!!====================================================== ======
!! Engineering Bits
!!====================================================== ======
  Eng_bits_120_121 = 0                        ! Byte 78-79 ! Address 60

!!====================================================== ======
!!SNMPOID Number ! TBD
!!====================================================== ======

  SOID_122 = 0
  SOID_123 = 0
  SOID_122_123 = shift(SOID_122,-8) + SOID_123  ! Byte 7A-7B ! Address 61
  SOID_124 = 0
  SOID_125 = 0
  SOID_124_125 = shift(SOID_124,-8) + SOID_125  ! Byte 7C-7D ! Address 62
  SOID_126 = 0
  SOID_127 = 0
  SOID_126_127 = shift(SOID_126,-8) + SOID_127  ! Byte 7E-7F ! Address 63
  SOID_128 = 0
  SOID_129 = 0
  SOID_128_129 = shift(SOID_128,-8) + SOID_129  ! Byte 80-81 ! Address 64
  SOID_130 = 0
  SOID_131 = 0
  SOID_130_131 = shift(SOID_130,-8) + SOID_131  ! Byte 82-83 ! Address 65
  SOID_132 = 0
  SOID_133 = 0
  SOID_132_133 = shift(SOID_132,-8) + SOID_133  ! Byte 84-85 ! Address 66
  SOID_134 = 0
  SOID_135 = 0
  SOID_134_135 = shift(SOID_134,-8) + SOID_135  ! Byte 86-87 ! Address 67
  SOID_136 = 0
  SOID_137 = 0
  SOID_136_137 = shift(SOID_136,-8) + SOID_137  ! Byte 88-89 ! Address 68

!!====================================================== ======
!! Power Consumption
!!====================================================== ======
  PWR_Com_138_139 = -4100                       ! Byte 8A-8B ! Address 69
  PWR_Com_138_139 = binand (PWR_Com_138_139,65535)

!!====================================================== ======
!! RMA Failure Code ! Reset = 0
!!====================================================== ======
  RMA_Fco_140_141 = 0                         ! Byte 8C-8D ! Address 70
  RMA_Fco_142_143 = 0                         ! Byte 8E-8F ! Address 71

!!====================================================== ======
!!CLEI CODES
!!====================================================== ======
  CLEI_Code_144_155$ = "12345678"           ! Byte 90-9B ! Address 72-77
  call Chklength_S(CLEI_Code_144_155$,12)
!!====================================================== ======
!!VID
!!====================================================== ======

  VID_156_159$ = "VID"                          ! Byte 9C-9F ! Address 78-79
  call Chklength_S(VID_156_159$,4)

!################################################################### #####!
!** SPROM FRU Specific Block                                             !
!** BLOCK 2  in WORD = (16 bits)                                         !
!################################################################### #####!
  Block_Sig_160_161 = hti("6002")  ! Hex       ! Byte A0-A1 ! Address 80
    Block_ver2 = 2                             ! Byte A2-A3 ! Address 81
    Block_len2 = 103
  Block_ver_len_162_163 = shift(Block_ver2,-8) + Block_len2

!!====================================================== ======
!! Block 2 Check Sum
!!====================================================== ======
   Check_sum_164_165 = 0                       ! Byte A4-A5 ! Address 82

!!====================================================== ======
!! Feature Bits
!!====================================================== ======
   Feature_b_166_167 = hti("0000")             ! Byte A6-A7 ! Address 83
   Feature_b_168_169 = hti("0000")             ! Byte A8-A9 ! Address 84
   Feature_b_170_171 = hti("0000")             ! Byte AA-AB ! Address 85
   Feature_b_172_173 = hti("0000")             ! Byte AC-AD ! Address 86

!!====================================================== ======
! Hardware Changes Bits
!!====================================================== ======
   HChange_b_174_175 = hti("0000")             ! Byte AE-AF ! Address 87
   HChange_b_176_177 = hti("0000")             ! Byte B0-B1 ! Address 88
   HChange_b_178_179 = hti("0000")             ! Byte B2-B3 ! Address 89
   HChange_b_180_181 = hti("0000")             ! Byte B4-B5 ! Address 90

!!====================================================== ======
!! Card_Index
!!====================================================== ======
   Card_indx_182_183 = 21151                   ! Byte B6-B7 ! Address 91
   print tab(5); "Feature Index: "; val$(Card_indx_182_183)

!!====================================================== ======
!! Mac_base
!!====================================================== ======
! TBD

   Mac_base_184_185  = 00                     ! Byte B8-B9 ! Address 92
   Mac_base_186_187  = 00                     ! Byte BA-BB ! Address 93
   Mac_base_188_189  = 00                     ! Byte BC-BD ! Address 94

!!====================================================== ======
!! Mac_length
!!====================================================== ======
   Mac_len_190_191  = 0                       ! Byte BE-BF ! Address 95

!!====================================================== ======
!! Cpu_Epld_Num
!!====================================================== ======
   Cpu_Num_192      = 0                       ! Byte C0-C1 ! Address 96
   Epld_Num_193     = 0
   Cpu_Epld_192_193 = shift( Cpu_Num_192, -8) + Epld_Num_193

!!====================================================== ======
!! Epld_Version
!!====================================================== ======
   Epld_A_194_195   = 0                    ! Byte C2-C3 ! Address 97
   Epld_B_196_197   = 0                    ! Byte C4-C5 ! Address 98
   Epld_C_198_199   = 0                    ! Byte C6-C7 ! Address 99
   Epld_D_200_201   = 0                    ! Byte C8-C9 ! Address 100
   Epld_E_202_203   = 0                    ! Byte CA-CB ! Address 101
   Epld_F_204_205   = 0                    ! Byte CC-CD ! Address 102
   Epld_G_206_207   = 0                    ! Byte CE-CF ! Address 103
   Epld_H_208_209   = 0                    ! Byte D0-D1 ! Address 104
   Epld_I_210_211   = 0                    ! Byte D2-D3 ! Address 105
   Epld_J_212_213   = 0                    ! Byte D4-D5 ! Address 106
   Epld_K_214_215   = 0                    ! Byte D6-D7 ! Address 107
   Epld_L_216_217   = 0                    ! Byte D8-D9 ! Address 108
   Epld_M_218_219   = 0                    ! Byte DA-DB ! Address 109
   Epld_N_220_221   = 0                    ! Byte DC-DD ! Address 110
   Epld_O_222_223   = 0                    ! Byte DE-DF ! Address 111

!!====================================================== ======
!! Port Type Number
!!====================================================== ======
   Port_Num_224_225_1 = 0
   Port_Num_224_225_2 = 0
   Port_Num_224_225 = shift( Port_Num_224_225_1, -8) +  Port_Num_224_225_2
   Port_Num_226_227_1 = 0
   Port_Num_226_227_2 = 0
   Port_Num_226_227 = shift( Port_Num_226_227_1, -8) +  Port_Num_226_227_2
   Port_Num_228_229_1 = 0
   Port_Num_228_229_2 = 0
   Port_Num_228_229 = shift( Port_Num_228_229_1, -8) +  Port_Num_228_229_2
   Port_Num_230_231_1 = 0
   Port_Num_230_231_2 = 0
   Port_Num_230_231 = shift( Port_Num_230_231_1, -8) +  Port_Num_230_231_2
   Port_Num_232_233_1 = 0
   Port_Num_232_233_2 = 0
   Port_Num_232_233 = shift( Port_Num_232_233_1, -8) +  Port_Num_232_233_2
   Port_Num_234_235_1 = 0
   Port_Num_234_235_2 = 0
   Port_Num_234_235 = shift( Port_Num_234_235_1, -8) +  Port_Num_234_235_2
   Port_Num_236_237_1 = 0
   Port_Num_236_237_2 = 0
   Port_Num_236_237 = shift( Port_Num_236_237_1, -8) +  Port_Num_236_237_2
   Port_Num_238_239_1 = 0
   Port_Num_238_239_2 = 0
   Port_Num_238_239 = shift( Port_Num_238_239_1, -8) +  Port_Num_238_239_2

!!====================================================== ======
!! Sram_Size
!!====================================================== ======
   Sram_Size_240_241 = 0                      ! Byte F0-F1 ! Address 120

!!====================================================== ======
!! Sensor Major/ Minor
!!====================================================== ======
!* Sensor # 1
   Sensor_242 = -128                             ! Byte F2-F3 ! Address 121
   Sensor_243 = -128
   Sensor_242 = binand (Sensor_242,255)
   Sensor_243 = binand (Sensor_243,255)
   Sensor_242_243 = shift( Sensor_242, -8) + Sensor_243

!* Sensor # 2
   Sensor_244 = -128                              ! Byte F4-F5 ! Address 122
   Sensor_245 = -128
   Sensor_244 = binand (Sensor_244,255)
   Sensor_245 = binand (Sensor_245,255)
   Sensor_244_245 = shift( Sensor_244, -8) + Sensor_245

!* Sensor # 3
   Sensor_246 = -128                              ! Byte F6-F7 ! Address 123
   Sensor_247 = -128
   Sensor_246 = binand (Sensor_246,255)
   Sensor_247 = binand (Sensor_247,255)
   Sensor_246_247 = shift( Sensor_246, -8) + Sensor_247

!* Sensor # 4
   Sensor_248 = -128                              ! Byte F8-F9 ! Address 124
   Sensor_249 = -128
   Sensor_248 = binand (Sensor_248,255)
   Sensor_249 = binand (Sensor_249,255)
   Sensor_248_249 = shift( Sensor_248, -8) + Sensor_249

!* Sensor # 5
   Sensor_250 = -128                            ! Byte FA-FB ! Address 125
   Sensor_251 = -128
   Sensor_250 = binand (Sensor_250,255)
   Sensor_251 = binand (Sensor_251,255)
   Sensor_250_251 = shift( Sensor_250, -8) + Sensor_251

!* Sensor # 6
   Sensor_252 = -128                           ! Byte FC-FD ! Address 126
   Sensor_253 = -128
   Sensor_252 = binand (Sensor_252,255)
   Sensor_253 = binand (Sensor_253,255)
   Sensor_252_253 = shift( Sensor_252, -8) + Sensor_253

!* Sensor # 7
   Sensor_254 = -128                             ! Byte FE-FF ! Address 127
   Sensor_255 = -128
   Sensor_254 = binand (Sensor_254,255)
   Sensor_255 = binand (Sensor_255,255)
   Sensor_254_255 = shift( Sensor_254, -8) + Sensor_255

!* Sensor # 8
   Sensor_256 =  -128                              ! Byte 100-101!Address 128
   Sensor_257 =  -128
   Sensor_256 = binand (Sensor_256,255)
   Sensor_257 = binand (Sensor_257,255)
   Sensor_256_257 = shift( Sensor_256, -8) + Sensor_257

!!=====================================
!* Max Connector Power
!!======================================
   Max_Connector_Pwr_258_259 = 8300              ! Byte 102-103!Address 129

!!=====================================
!* Cooling Requirements
!!=====================================
   Cooling_Requirements_260_261 = 175             ! Byte 104-105!Address 130

!!=====================================
!* Ambient Temperature
!!=====================================
   Ambient_Temperature_262 = 55                  ! Byte 106-107!Address 131

!################################################################### #####!
!** SPROM Sensor Block                                                   !
!** BLOCK 3  in WORD = (16 bits)                                         !
!################################################################### #####!
   Block_Sig_263 = hti("60")  ! Hex
   Block_Sig_264 = hti("08")  ! Hex

!!====================================================== ======
!! Block Version Length
!!====================================================== ======
   Block_ver_265 = 1
   Block_len_266 = 71

!!====================================================== ======
!! Block Check Sum
!!====================================================== ======
   Check_sum_267 = 0
   Check_sum_268 = 0

!!====================================================== ======
!! Number of Sensors
!!====================================================== ======
   Number_of_Sensors_269 = 0

   Block_262_263 = shift(Ambient_Temperature_262,-8) + Block_Sig_263
   Block_264_265 = shift(Block_Sig_264,-8) + Block_ver_265
   Block_266_267 = shift(Block_len_266,-8) + Check_sum_267
   Block_268_269 = shift(Check_sum_268,-8) + Number_of_Sensors_269

!!====================================================== ======
!! Sensor Major/ Minor
!!====================================================== ======
!* Sensor # 1
   Sensor_270 = -128
   Sensor_271 = -128
   Sensor_270 = binand (Sensor_270,255)
   Sensor_271 = binand (Sensor_271,255)
   Sensor_270_271 = shift( Sensor_270, -8) + Sensor_271

!* Sensor # 2
   Sensor_272 = -128
   Sensor_273 = -128
   Sensor_272 = binand (Sensor_272,255)
   Sensor_273 = binand (Sensor_273,255)
   Sensor_272_273 = shift( Sensor_272, -8) + Sensor_273

!* Sensor # 3
   Sensor_274 = -128
   Sensor_275 = -128
   Sensor_274 = binand (Sensor_274,255)
   Sensor_275 = binand (Sensor_275,255)
   Sensor_274_275 = shift( Sensor_274, -8) + Sensor_275

!* Sensor # 4
   Sensor_276 = -128
   Sensor_277 = -128
   Sensor_276 = binand (Sensor_276,255)
   Sensor_277 = binand (Sensor_277,255)
   Sensor_276_277 = shift( Sensor_276, -8) + Sensor_277

!* Sensor # 5
   Sensor_278 = -128
   Sensor_279 = -128
   Sensor_278 = binand (Sensor_278,255)
   Sensor_279 = binand (Sensor_279,255)
   Sensor_278_279 = shift( Sensor_278, -8) + Sensor_279

!* Sensor # 6
   Sensor_280 = -128
   Sensor_281 = -128
   Sensor_280 = binand (Sensor_280,255)
   Sensor_281 = binand (Sensor_281,255)
   Sensor_280_281 = shift( Sensor_280, -8) + Sensor_281

!* Sensor # 7
   Sensor_282 = -128
   Sensor_283 = -128
   Sensor_282 = binand (Sensor_282,255)
   Sensor_283 = binand (Sensor_283,255)
   Sensor_282_283 = shift( Sensor_282, -8) + Sensor_283

!* Sensor # 8
   Sensor_284 = -128
   Sensor_285 = -128
   Sensor_284 = binand (Sensor_284,255)
   Sensor_285 = binand (Sensor_285,255)
   Sensor_284_285 = shift( Sensor_284, -8) + Sensor_285

!* Sensor # 9
   Sensor_286 = -128
   Sensor_287 = -128
   Sensor_286 = binand (Sensor_286,255)
   Sensor_287 = binand (Sensor_287,255)
   Sensor_286_287 = shift( Sensor_286, -8) + Sensor_287

!* Sensor # 10
   Sensor_288 = -128
   Sensor_289 = -128
   Sensor_288 = binand (Sensor_288,255)
   Sensor_289 = binand (Sensor_289,255)
   Sensor_288_289 = shift( Sensor_288, -8) + Sensor_289

!* Sensor # 11
   Sensor_290 = -128
   Sensor_291 = -128
   Sensor_290 = binand (Sensor_290,255)
   Sensor_291 = binand (Sensor_291,255)
   Sensor_290_291 = shift( Sensor_290, -8) + Sensor_291

!* Sensor # 12
   Sensor_292 = -128
   Sensor_293 = -128
   Sensor_292 = binand (Sensor_292,255)
   Sensor_293 = binand (Sensor_293,255)
   Sensor_292_293 = shift( Sensor_292, -8) + Sensor_293

!* Sensor # 13
   Sensor_294 = -128
   Sensor_295 = -128
   Sensor_294 = binand (Sensor_294,255)
   Sensor_295 = binand (Sensor_295,255)
   Sensor_294_295 = shift( Sensor_294, -8) + Sensor_295

!* Sensor # 14
   Sensor_296 = -128
   Sensor_297 = -128
   Sensor_296 = binand (Sensor_296,255)
   Sensor_297 = binand (Sensor_297,255)
   Sensor_296_297 = shift( Sensor_296, -8) + Sensor_297

!* Sensor # 15
   Sensor_298 = -128
   Sensor_299 = -128
   Sensor_298 = binand (Sensor_298,255)
   Sensor_299 = binand (Sensor_299,255)
   Sensor_298_299 = shift( Sensor_298, -8) + Sensor_299

!* Sensor # 16
   Sensor_300 = -128
   Sensor_301 = -128
   Sensor_300 = binand (Sensor_300,255)
   Sensor_301 = binand (Sensor_301,255)
   Sensor_300_301 = shift( Sensor_300, -8) + Sensor_301

!* Sensor # 17
   Sensor_302 = -128
   Sensor_303 = -128
   Sensor_302 = binand (Sensor_302,255)
   Sensor_303 = binand (Sensor_303,255)
   Sensor_302_303 = shift( Sensor_302, -8) + Sensor_303

!* Sensor # 18
   Sensor_304 = -128
   Sensor_305 = -128
   Sensor_304 = binand (Sensor_304,255)
   Sensor_305 = binand (Sensor_305,255)
   Sensor_304_305 = shift( Sensor_304, -8) + Sensor_305

!* Sensor # 19
   Sensor_306 = -128
   Sensor_307 = -128
   Sensor_306 = binand (Sensor_306,255)
   Sensor_307 = binand (Sensor_307,255)
   Sensor_306_307 = shift( Sensor_306, -8) + Sensor_307

!* Sensor # 20
   Sensor_308 = -128
   Sensor_309 = -128
   Sensor_308 = binand (Sensor_308,255)
   Sensor_309 = binand (Sensor_309,255)
   Sensor_308_309 = shift( Sensor_308, -8) + Sensor_309

!* Sensor # 21
   Sensor_310 = -128
   Sensor_311 = -128
   Sensor_310 = binand (Sensor_310,255)
   Sensor_311 = binand (Sensor_311,255)
   Sensor_310_311 = shift( Sensor_310, -8) + Sensor_311

!* Sensor # 22
   Sensor_312 = -128
   Sensor_313 = -128
   Sensor_312 = binand (Sensor_312,255)
   Sensor_313 = binand (Sensor_313,255)
   Sensor_312_313 = shift( Sensor_312, -8) + Sensor_313

!* Sensor # 23
   Sensor_314 = -128
   Sensor_315 = -128
   Sensor_314 = binand (Sensor_314,255)
   Sensor_315 = binand (Sensor_315,255)
   Sensor_314_315 = shift( Sensor_314, -8) + Sensor_315

!* Sensor # 24
   Sensor_316 = -128
   Sensor_317 = -128
   Sensor_316 = binand (Sensor_314,255)
   Sensor_317 = binand (Sensor_315,255)
   Sensor_316_317 = shift( Sensor_314, -8) + Sensor_315

!* Sensor # 25
   Sensor_318 = -128
   Sensor_319 = -128
   Sensor_318 = binand (Sensor_314,255)
   Sensor_319 = binand (Sensor_315,255)
   Sensor_318_319 = shift( Sensor_314, -8) + Sensor_315

!* Sensor # 26
   Sensor_320 = -128
   Sensor_321 = -128
   Sensor_320 = binand (Sensor_314,255)
   Sensor_321 = binand (Sensor_315,255)
   Sensor_320_321 = shift( Sensor_314, -8) + Sensor_315

!* Sensor # 27
   Sensor_322 = -128
   Sensor_323 = -128
   Sensor_322 = binand (Sensor_314,255)
   Sensor_323 = binand (Sensor_315,255)
   Sensor_322_323 = shift( Sensor_314, -8) + Sensor_315

!* Sensor # 28
   Sensor_324 = -128
   Sensor_325 = -128
   Sensor_324 = binand (Sensor_314,255)
   Sensor_325 = binand (Sensor_315,255)
   Sensor_324_325 = shift( Sensor_314, -8) + Sensor_315

!* Sensor # 29
   Sensor_326 = -128
   Sensor_327 = -128
   Sensor_326 = binand (Sensor_314,255)
   Sensor_327 = binand (Sensor_315,255)
   Sensor_326_327 = shift( Sensor_314, -8) + Sensor_315

!* Sensor # 30
   Sensor_328 = -128
   Sensor_329 = -128
   Sensor_328 = binand (Sensor_314,255)
   Sensor_329 = binand (Sensor_315,255)
   Sensor_328_329 = shift( Sensor_314, -8) + Sensor_315

!* Sensor # 31
   Sensor_330 = -128
   Sensor_331 = -128
   Sensor_330 = binand (Sensor_314,255)
   Sensor_331 = binand (Sensor_315,255)
   Sensor_330_331 = shift( Sensor_314, -8) + Sensor_315

!* Sensor # 32
   Sensor_332 = -128
   Sensor_333 = -128
   Sensor_332 = binand (Sensor_314,255)
   Sensor_333 = binand (Sensor_315,255)
   Sensor_332_333 = shift( Sensor_314, -8) + Sensor_315

!* Data 334 to 383 are all filled with FFFF

   Empty_334_335 = 65535
   Empty_336_337 = 65535
   Empty_338_339 = 65535
   Empty_340_341 = 65535
   Empty_342_343 = 65535
   Empty_344_345 = 65535
   Empty_346_346 = 65535
   Empty_348_349 = 65535
   Empty_350_351 = 65535
   Empty_352_353 = 65535
   Empty_354_355 = 65535
   Empty_356_357 = 65535
   Empty_358_359 = 65535
   Empty_360_361 = 65535
   Empty_362_363 = 65535
   Empty_364_365 = 65535
   Empty_366_367 = 65535
   Empty_368_369 = 65535
   Empty_370_371 = 65535
   Empty_372_373 = 65535
   Empty_374_375 = 65535
   Empty_376_377 = 65535
   Empty_378_379 = 65535
   Empty_380_381 = 65535

!!====================================================== ======
!! Padding
!! Routine below to handle data generation for this field
!!====================================================== ======
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!*************  END OF PCAMAP TABLE ***********************!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!! WARNINGS !! WARNINGS !! WARNINGS !! WARNINGS !! !!!!!!!
!!!!!! WARNINGS !! WARNINGS !! WARNINGS !! WARNINGS !! !!!!!!!
!!!!!! WARNINGS !! WARNINGS !! WARNINGS !! WARNINGS !! !!!!!!!
!!!!!!         DO NOT MODIFY FROM THIS LINE ON         !!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!$$$$$$ GENERATE MEMORY TABLE  $$$$$$$$$$$$$$$$$$$$$$$$$$$$!!
!!====================================================== ====!!
   Mem_Table(0) = Block_sig_0_1
   Mem_Table(1) = Block_ver_len_2_3
   Mem_Table(2) = Check_sum_4_5      !! Xsum1 / BLK 1
   Mem_Table(3) = Eprom_size_6_7
   Mem_Table(4) = Block_count_8_9
   Mem_Table(5) = Fru_maj_10_11
   Mem_Table(6) = Fru_min_12_13
!!
!!
  for V1 = 1 to 20 ! Character Byte
      Temp = num(OEM_Str$[V1;1])
      if Temp = 92 then
         Test(V1) = 0  ! "\" = 92
        else
           Test(V1) = num(OEM_Str$[V1;1])
      end if
  next V1


  for L1 = 0 to 9  ! Word  - For Mem_Table(7-16) Locations
     Mem_Table(7+L1) = shift( Test(2*L1+1), -8 ) + Test(2*L1+2) ! "Cisco..."
  next L1
!!

  for V = 1 to 20 ! Character Byte
      Temp = num(Prod_Num$[V;1])
      if Temp = 92 then
         Test(V) = 0  ! "\" = 92
        else
           Test(V) = num(Prod_Num$[V;1])
      end if
  next V

  for L = 0 to 9  ! Word  - For Mem_Table(17-26) Locations
     Mem_Table(17+L) = shift( Test(2*L+1), -8 ) + Test(2*L+2) ! "WS....."
  next L

!!====================================================== ======
!! Board Part Number ! Reset = 0 ! Ex.73-15576-03 => 73/15287/04
!!====================================================== ======

  for V1 = 1 to 16 ! Character Byte
      Temp = num(Part_N_74_89$[V1;1])
      if Temp = 92 then
         Test(V1) = 0  ! "\" = 92
          else
           Test(V1) = num(Part_N_74_89$[V1;1])
      end if
  next V1

  for L = 0 to 7  ! Word  - For Mem_Table(37-44) Locations
     Mem_Table(37+L) = shift( Test(2*L+1), -8 ) + Test(2*L+2)
  next L

!!====================================================== =========
!! Mem_Table(45-46)
  for V = 1 to 4 ! Character Byte
      Temp = num(Part_R_90_93$[V;1])
      if Temp = 92 then
         Test(V) = 0  ! "\" = 92
        else
           Test(V) = num(Part_R_90_93$[V;1])
      end if
  next V

  for L = 0 to 1  ! Word  - For Mem_Table(45-46) Locations
     Mem_Table(45+L) = shift( Test(2*L+1), -8 ) + Test(2*L+2)
  next L
!!====================================================== =========
!! Mem_Table(47-56)
  for V = 1 to 20 ! Character Byte
      Temp = num(Mfg_Dev_94_113$[V;1])
      if Temp = 92 then
         Test(V) = 0  ! "\" = 92
        else
           Test(V) = num(Mfg_Dev_94_113$[V;1])
      end if
  next V

  for L = 0 to 9  ! Word  - For Mem_Table(47-56) Locations
     Mem_Table(47+L) = shift( Test(2*L+1), -8 ) + Test(2*L+2)
  next L
!!====================================================== =========
   Mem_Table(57) = Hw_Rev_maj_114_115
   Mem_Table(58) = Hw_Rev_min_116_117
   Mem_Table(59) = Mfg_bits_118_119
   Mem_Table(60) = Eng_bits_120_121
   Mem_Table(61) = SOID_122_123
   Mem_Table(62) = SOID_124_125
   Mem_Table(63) = SOID_126_127
   Mem_Table(64) = SOID_128_129
   Mem_Table(65) = SOID_130_131
   Mem_Table(66) = SOID_132_133
   Mem_Table(67) = SOID_134_135
   Mem_Table(68) = SOID_136_137
   Mem_Table(69) = PWR_Com_138_139
   Mem_Table(70) = RMA_Fco_140_141
   Mem_Table(71) = RMA_Fco_142_143

  for V1 = 1 to 12 ! Character Byte
      Temp = num(CLEI_Code_144_155$[V1;1])
      if Temp = 92 then
         Test(V1) = 0  ! "\" = 92
        else
           Test(V1) = num(CLEI_Code_144_155$[V1;1])
      end if
  next V1

  for L1 = 0 to 5  ! Word  - For Mem_Table(7-16) Locations
     Mem_Table(72+L1) = shift( Test(2*L1+1), -8 ) + Test(2*L1+2) ! "Cisco..."
  next L1

!!====================================================== =========

   for V1 = 1 to 4  ! Character Byte
      Temp = num(VID_156_159$[V1;1])
      if Temp = 92 then
         Test(V1) = 0  ! "\" = 92
        else
           Test(V1) = num(VID_156_159$[V1;1])
      end if
   next V1

   for L1 = 0 to 1  ! Word
     Mem_Table(78+L1) = shift( Test(2*L1+1), -8 ) + Test(2*L1+2)
   next L1


!!====================================================== ======
!** BLOCK 2  in WORD = (16 bits)
!!====================================================== ======
   Mem_Table(80) =  Block_Sig_160_161
   Mem_Table(81) =  Block_ver_len_162_163
   Mem_Table(82) =  Check_sum_164_165    !! Xsum2 / BLK 2
   Mem_Table(83) =  Feature_b_166_167
   Mem_Table(84) =  Feature_b_168_169
   Mem_Table(85) =  Feature_b_170_171
   Mem_Table(86) =  Feature_b_172_173
   Mem_Table(87) =  HChange_b_174_175
   Mem_Table(88) =  HChange_b_176_177
   Mem_Table(89) =  HChange_b_178_179
   Mem_Table(90) =  HChange_b_180_181
   Mem_Table(91) =  Card_Indx_182_183
   Mem_Table(92) =  Mac_base_184_185
   Mem_Table(93) =  Mac_base_186_187
   Mem_Table(94) =  Mac_base_188_189
   Mem_Table(95) =  Mac_len_190_191
   Mem_Table(96) =  Cpu_Epld_192_193
   Mem_Table(97) =  Epld_A_194_195
   Mem_Table(98) =  Epld_B_196_197
   Mem_Table(99) =  Epld_C_198_199
   Mem_Table(100) = Epld_D_200_201
   Mem_Table(101) = Epld_E_202_203
   Mem_Table(102) = Epld_F_204_205
   Mem_Table(103) = Epld_G_206_207
   Mem_Table(104) = Epld_H_208_209
   Mem_Table(105) = Epld_I_210_211
   Mem_Table(106) = Epld_J_212_213
   Mem_Table(107) = Epld_K_214_215
   Mem_Table(108) = Epld_L_216_217
   Mem_Table(109) = Epld_M_218_219
   Mem_Table(110) = Epld_N_220_221
   Mem_Table(111) = Epld_O_222_223
   Mem_Table(112) = Port_Num_224_225
   Mem_Table(113) = Port_Num_226_227
   Mem_Table(114) = Port_Num_228_229
   Mem_Table(115) = Port_Num_230_231
   Mem_Table(116) = Port_Num_232_233
   Mem_Table(117) = Port_Num_234_235
   Mem_Table(118) = Port_Num_236_237
   Mem_Table(119) = Port_Num_238_239
   Mem_Table(120) = Sram_Size_240_241
   Mem_Table(121) = Sensor_242_243
   Mem_Table(122) = Sensor_244_245
   Mem_Table(123) = Sensor_246_247
   Mem_Table(124) = Sensor_248_249
   Mem_Table(125) = Sensor_250_251
   Mem_Table(126) = Sensor_252_253
   Mem_Table(127) = Sensor_254_255
   Mem_Table(128) = Sensor_256_257
   Mem_Table(129) = Max_Connector_Pwr_258_259
   Mem_Table(130) = Cooling_Requirements_260_261

!!====================================================== ======
!** BLOCK 3  in WORD = (16 bits)
!!====================================================== ======
   Mem_Table(131) = Block_262_263
   Mem_Table(132) = Block_264_265
   Mem_Table(133) = Block_266_267
   Mem_Table(134) = Block_268_269
   Mem_Table(135) = Sensor_270_271
   Mem_Table(136) = Sensor_272_273
   Mem_Table(137) = Sensor_274_275
   Mem_Table(138) = Sensor_276_277
   Mem_Table(139) = Sensor_278_279
   Mem_Table(140) = Sensor_280_281
   Mem_Table(141) = Sensor_282_283
   Mem_Table(142) = Sensor_284_285
   Mem_Table(143) = Sensor_286_287
   Mem_Table(144) = Sensor_288_289
   Mem_Table(145) = Sensor_290_291
   Mem_Table(146) = Sensor_292_293
   Mem_Table(147) = Sensor_294_295
   Mem_Table(148) = Sensor_296_297
   Mem_Table(149) = Sensor_298_299
   Mem_Table(150) = Sensor_300_301
   Mem_Table(151) = Sensor_302_303
   Mem_Table(152) = Sensor_304_305
   Mem_Table(153) = Sensor_306_307
   Mem_Table(154) = Sensor_308_309
   Mem_Table(155) = Sensor_310_311
   Mem_Table(156) = Sensor_312_313
   Mem_Table(157) = Sensor_314_315
   Mem_Table(158) = Sensor_316_317
   Mem_Table(159) = Sensor_318_319
   Mem_Table(160) = Sensor_320_321
   Mem_Table(161) = Sensor_322_323
   Mem_Table(162) = Sensor_324_325
   Mem_Table(163) = Sensor_326_327
   Mem_Table(164) = Sensor_328_329
   Mem_Table(165) = Sensor_330_331
   Mem_Table(166) = Sensor_332_333
   Mem_Table(167) = Empty_334_335
   Mem_Table(168) = Empty_334_335
   Mem_Table(169) = Empty_336_337
   Mem_Table(170) = Empty_338_339
   Mem_Table(171) = Empty_340_341
   Mem_Table(172) = Empty_342_343
   Mem_Table(173) = Empty_344_345
   Mem_Table(174) = Empty_346_346
   Mem_Table(175) = Empty_348_349
   Mem_Table(176) = Empty_350_351
   Mem_Table(177) = Empty_352_353
   Mem_Table(178) = Empty_354_355
   Mem_Table(179) = Empty_356_357
   Mem_Table(180) = Empty_358_359
   Mem_Table(181) = Empty_360_361
   Mem_Table(182) = Empty_362_363
   Mem_Table(183) = Empty_364_365
   Mem_Table(184) = Empty_366_367
   Mem_Table(185) = Empty_368_369
   Mem_Table(186) = Empty_370_371
   Mem_Table(187) = Empty_372_373
   Mem_Table(188) = Empty_374_375
   Mem_Table(189) = Empty_376_377
   Mem_Table(190) = Empty_378_379
   Mem_Table(191) = Empty_380_381

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!! Checksum Calculations
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! BLOCK 1
  XsumB1 = 0
  for Word =  0 to 79
    if Word = 2 then goto Skip1
     Crc_LB0 = binand (Mem_Table(Word),255)
     Crc_SR8 = binand (shift(Mem_Table(Word), 8),255)
     XsumB1 = XsumB1 + Crc_LB0 + Crc_SR8
     if XsumB1 > 65535 then XsumB1 = binand(XsumB1,65535)
   Skip1:
  next Word

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! BLOCK 2
  XsumB2 = 0
  for Word = 80 to 131
    if Word = 82 then goto Skip2
     Crc_LB0 = binand (Mem_Table(Word),255)
     Crc_SR8 = binand (shift(Mem_Table(Word), 8),255)
     if Word = 131 then
       XsumB2 = XsumB2 + Crc_SR8
     else
       XsumB2 = XsumB2 + Crc_LB0 + Crc_SR8
     end if
     if XsumB2 > 65535 then XsumB2 = binand(XsumB2,65535)
   Skip2:
  next Word

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! BLOCK 3
  XsumB3 = 0

  for Word = 131 to 166
     Crc_LB0 = binand (Mem_Table(Word),255)
     Crc_SR8 = binand (shift(Mem_Table(Word), 8),255)

     if Word = 131 then
       XsumB3 = XsumB3 + Crc_LB0
     else
       XsumB3 = XsumB3 + Crc_LB0 + Crc_SR8
     end if

     if XsumB3 > 65535 then XsumB3 = binand(XsumB3,65535)
  next Word

  Checksum_3_Hex$ = ith$(XsumB3)
  if len(Checksum_3_Hex$)=1 then Checksum_3_Hex$ = "000" & Checksum_3_Hex$
  if len(Checksum_3_Hex$)=2 then Checksum_3_Hex$ = "00" & Checksum_3_Hex$
  if len(Checksum_3_Hex$)=3 then Checksum_3_Hex$ = "0" & Checksum_3_Hex$

  Checksum_3_High$ = Checksum_3_Hex$[1;2]
  Checksum_3_Low$  = Checksum_3_Hex$[3;2]

  Check_sum_267 = hti(Checksum_3_High$)
  Check_sum_268 = hti(Checksum_3_Low$)

  Block_266_267 = shift(Block_len_266,-8) + Check_sum_267
  Block_268_269 = shift(Check_sum_268,-8) + Number_of_Sensors_269

! Store new check sum values

  Mem_Table(2)    =  XsumB1           !block 1
  Mem_Table(82)   =  XsumB2           !blocK 2
  Mem_Table(133)  =  Block_266_267    !block 3
  Mem_Table(134)  =  Block_268_269    !block 3

!! testonly
! print "Check Sum Blk #1 = ", Mem_Table(2)
! print "Check Sum Blk #2 = ", Mem_Table(82)
! print "Check Sum Blk #3 = ", Mem_Table(XX)

for Cnt1 = 0 to 63 !!
   EE_D1(Cnt1*16+0)  = binand(shift(Mem_Table(Cnt1), 8),1)
   EE_D1(Cnt1*16+1)  = binand(shift(Mem_Table(Cnt1), 9),1)
   EE_D1(Cnt1*16+2)  = binand(shift(Mem_Table(Cnt1),10),1)
   EE_D1(Cnt1*16+3)  = binand(shift(Mem_Table(Cnt1),11),1)
   EE_D1(Cnt1*16+4)  = binand(shift(Mem_Table(Cnt1),12),1)
   EE_D1(Cnt1*16+5)  = binand(shift(Mem_Table(Cnt1),13),1)
   EE_D1(Cnt1*16+6)  = binand(shift(Mem_Table(Cnt1),14),1)
   EE_D1(Cnt1*16+7)  = binand(shift(Mem_Table(Cnt1),15),1)
   EE_D1(Cnt1*16+8)  = binand(shift(Mem_Table(Cnt1), 0),1)
   EE_D1(Cnt1*16+9)  = binand(shift(Mem_Table(Cnt1), 1),1)
   EE_D1(Cnt1*16+10) = binand(shift(Mem_Table(Cnt1), 2),1)
   EE_D1(Cnt1*16+11) = binand(shift(Mem_Table(Cnt1), 3),1)
   EE_D1(Cnt1*16+12) = binand(shift(Mem_Table(Cnt1), 4),1)
   EE_D1(Cnt1*16+13) = binand(shift(Mem_Table(Cnt1), 5),1)
   EE_D1(Cnt1*16+14) = binand(shift(Mem_Table(Cnt1), 6),1)
   EE_D1(Cnt1*16+15) = binand(shift(Mem_Table(Cnt1), 7),1)
next Cnt1

  for I = 0 to 1023
   EE_R1(I) = EE_D1(I)
  next I

for Cnt1 = 0 to 63 !!
   EE_D2(Cnt1*16+0)  = binand(shift(Mem_Table(Cnt1+64), 8),1)
   EE_D2(Cnt1*16+1)  = binand(shift(Mem_Table(Cnt1+64), 9),1)
   EE_D2(Cnt1*16+2)  = binand(shift(Mem_Table(Cnt1+64),10),1)
   EE_D2(Cnt1*16+3)  = binand(shift(Mem_Table(Cnt1+64),11),1)
   EE_D2(Cnt1*16+4)  = binand(shift(Mem_Table(Cnt1+64),12),1)
   EE_D2(Cnt1*16+5)  = binand(shift(Mem_Table(Cnt1+64),13),1)
   EE_D2(Cnt1*16+6)  = binand(shift(Mem_Table(Cnt1+64),14),1)
   EE_D2(Cnt1*16+7)  = binand(shift(Mem_Table(Cnt1+64),15),1)
   EE_D2(Cnt1*16+8)  = binand(shift(Mem_Table(Cnt1+64), 0),1)
   EE_D2(Cnt1*16+9)  = binand(shift(Mem_Table(Cnt1+64), 1),1)
   EE_D2(Cnt1*16+10) = binand(shift(Mem_Table(Cnt1+64), 2),1)
   EE_D2(Cnt1*16+11) = binand(shift(Mem_Table(Cnt1+64), 3),1)
   EE_D2(Cnt1*16+12) = binand(shift(Mem_Table(Cnt1+64), 4),1)
   EE_D2(Cnt1*16+13) = binand(shift(Mem_Table(Cnt1+64), 5),1)
   EE_D2(Cnt1*16+14) = binand(shift(Mem_Table(Cnt1+64), 6),1)
   EE_D2(Cnt1*16+15) = binand(shift(Mem_Table(Cnt1+64), 7),1)
next Cnt1

  for I = 0 to 1023
   EE_R2(I) = EE_D2(I)
  next I

for Cnt1 = 0 to 63 !!
   EE_D3(Cnt1*16+0)  = binand(shift(Mem_Table(Cnt1+128), 8),1)
   EE_D3(Cnt1*16+1)  = binand(shift(Mem_Table(Cnt1+128), 9),1)
   EE_D3(Cnt1*16+2)  = binand(shift(Mem_Table(Cnt1+128),10),1)
   EE_D3(Cnt1*16+3)  = binand(shift(Mem_Table(Cnt1+128),11),1)
   EE_D3(Cnt1*16+4)  = binand(shift(Mem_Table(Cnt1+128),12),1)
   EE_D3(Cnt1*16+5)  = binand(shift(Mem_Table(Cnt1+128),13),1)
   EE_D3(Cnt1*16+6)  = binand(shift(Mem_Table(Cnt1+128),14),1)
   EE_D3(Cnt1*16+7)  = binand(shift(Mem_Table(Cnt1+128),15),1)
   EE_D3(Cnt1*16+8)  = binand(shift(Mem_Table(Cnt1+128), 0),1)
   EE_D3(Cnt1*16+9)  = binand(shift(Mem_Table(Cnt1+128), 1),1)
   EE_D3(Cnt1*16+10) = binand(shift(Mem_Table(Cnt1+128), 2),1)
   EE_D3(Cnt1*16+11) = binand(shift(Mem_Table(Cnt1+128), 3),1)
   EE_D3(Cnt1*16+12) = binand(shift(Mem_Table(Cnt1+128), 4),1)
   EE_D3(Cnt1*16+13) = binand(shift(Mem_Table(Cnt1+128), 5),1)
   EE_D3(Cnt1*16+14) = binand(shift(Mem_Table(Cnt1+128), 6),1)
   EE_D3(Cnt1*16+15) = binand(shift(Mem_Table(Cnt1+128), 7),1)
next Cnt1

  for I = 0 to 1023
   EE_R3(I) = EE_D3(I)
  next I

! **********************************************************************

  ! Data For Write Command and Header for page 1.

                                     ! Header for 1st 128 bytes
  for I = 0 to 15                    ! Initialize to $00
    Header1(I) = hti("00")
  next I

  Header1(0)   = hti("25")           ! Write Cookie Command = $25, $00
  Header1(1)   = hti("00")
  Header1(2)   = hti("83")           ! Length of the total message -
                                     !    excluding the command bytes
  Header1(3)   = hti("10")           ! Starting Address high byte
  Header1(4)   = hti("00")           ! Starting Address low byte
  Header1(5)   = hti("80")           ! Number bytes of Cookie,128 bytes

! **********************************************************************

  for I = 0 to 7                                      ! Header
   HDR1(I*16+0)  = binand(shift(Header1(I*2),0),1)
   HDR1(I*16+1)  = binand(shift(Header1(I*2),1),1)
   HDR1(I*16+2)  = binand(shift(Header1(I*2),2),1)
   HDR1(I*16+3)  = binand(shift(Header1(I*2),3),1)
   HDR1(I*16+4)  = binand(shift(Header1(I*2),4),1)
   HDR1(I*16+5)  = binand(shift(Header1(I*2),5),1)
   HDR1(I*16+6)  = binand(shift(Header1(I*2),6),1)
   HDR1(I*16+7)  = binand(shift(Header1(I*2),7),1)
   HDR1(I*16+8)  = binand(shift(Header1(I*2+1),0),1)
   HDR1(I*16+9)  = binand(shift(Header1(I*2+1),1),1)
   HDR1(I*16+10) = binand(shift(Header1(I*2+1),2),1)
   HDR1(I*16+11) = binand(shift(Header1(I*2+1),3),1)
   HDR1(I*16+12) = binand(shift(Header1(I*2+1),4),1)
   HDR1(I*16+13) = binand(shift(Header1(I*2+1),5),1)
   HDR1(I*16+14) = binand(shift(Header1(I*2+1),6),1)
   HDR1(I*16+15) = binand(shift(Header1(I*2+1),7),1)
  next I

! **********************************************************************
! ************************ CheckSum Calculation ************************
! **********************************************************************

   ! For 1st 128 bytes

   Chksum1 = 0                                  ! initialize to 0
   EE_Data1 = 0

   for I =  0 to 15                             ! Header
     Chksum1 = Chksum1 + binand(Header1(I),255)
   next I

   for I =  0 to 127                           ! Cookie data

      EE_DD1$ =""
      for G = 0 to 7
         B = (I * 8) + 7 - G
!        B = (I * 8) + G
         EE_DD1$ = EE_DD1$ & val$(EE_D1(B))
      next G
      EE_Data1 = bti(EE_DD1$)

   Chksum1 = Chksum1 + binand(EE_Data1,255)

   next I

   if Chksum1 > 65535 then Chksum1 = binand(Chksum1,65535)

   Chksum1   = bineor(Chksum1,255)  ! XOR with $FF, inverting data
   Chksum1   = binand(Chksum1,255)  ! Lower 8 bits only

   XSUM1(0)  = binand(shift(Chksum1,0),1)             ! Checksum
   XSUM1(1)  = binand(shift(Chksum1,1),1)
   XSUM1(2)  = binand(shift(Chksum1,2),1)
   XSUM1(3)  = binand(shift(Chksum1,3),1)
   XSUM1(4)  = binand(shift(Chksum1,4),1)
   XSUM1(5)  = binand(shift(Chksum1,5),1)
   XSUM1(6)  = binand(shift(Chksum1,6),1)
   XSUM1(7)  = binand(shift(Chksum1,7),1)

! **********************************************************************

  ! Data For Write Command and Header for page 2.

                                     ! Header for 2nd 128 bytes
  for I = 0 to 15                    ! Initialize to $00
    Header2(I) = hti("00")
  next I

  Header2(0)   = hti("25")           ! Write Cookie Command = $25, $00
  Header2(1)   = hti("00")
  Header2(2)   = hti("83")           ! Length of the total message -
                                     !    excluding the command bytes
  Header2(3)   = hti("10")           ! Starting Address high byte
  Header2(4)   = hti("80")           ! Starting Address low byte
  Header2(5)   = hti("80")           ! Number bytes of Cookie,128 bytes

! **********************************************************************

  for I = 0 to 7                                      ! Header
   HDR2(I*16+0)  = binand(shift(Header2(I*2),0),1)
   HDR2(I*16+1)  = binand(shift(Header2(I*2),1),1)
   HDR2(I*16+2)  = binand(shift(Header2(I*2),2),1)
   HDR2(I*16+3)  = binand(shift(Header2(I*2),3),1)
   HDR2(I*16+4)  = binand(shift(Header2(I*2),4),1)
   HDR2(I*16+5)  = binand(shift(Header2(I*2),5),1)
   HDR2(I*16+6)  = binand(shift(Header2(I*2),6),1)
   HDR2(I*16+7)  = binand(shift(Header2(I*2),7),1)
   HDR2(I*16+8)  = binand(shift(Header2(I*2+1),0),1)
   HDR2(I*16+9)  = binand(shift(Header2(I*2+1),1),1)
   HDR2(I*16+10) = binand(shift(Header2(I*2+1),2),1)
   HDR2(I*16+11) = binand(shift(Header2(I*2+1),3),1)
   HDR2(I*16+12) = binand(shift(Header2(I*2+1),4),1)
   HDR2(I*16+13) = binand(shift(Header2(I*2+1),5),1)
   HDR2(I*16+14) = binand(shift(Header2(I*2+1),6),1)
   HDR2(I*16+15) = binand(shift(Header2(I*2+1),7),1)
  next I

! **********************************************************************
! ************************ CheckSum Calculation ************************
! **********************************************************************
   ! For 2nd 128 bytes

   Chksum2 = 0                                  ! initialize to 0
   EE_Data2 = 0

   for I =  0 to 15                             ! Header
     Chksum2 = Chksum2 + binand(Header2(I),255)
   next I

   for I = 0 to 127                           ! Cookie data

      EE_DD2$ =""
      for G = 0 to 7
         B = (I * 8) + 7 - G
!        B = (I * 8) + G
         EE_DD2$ = EE_DD2$ & val$(EE_D2(B))
      next G

      EE_Data2 = bti(EE_DD2$)

   Chksum2 = Chksum2 + binand(EE_Data2,255)

   next I

   if Chksum2 > 65535 then Chksum2 = binand(Chksum2,65535)

   Chksum2   = bineor(Chksum2,255)  ! XOR with $FF, inverting data
   Chksum2   = binand(Chksum2,255)  ! Lower 8 bits only

   XSUM2(0)  = binand(shift(Chksum2,0),1)             ! Checksum
   XSUM2(1)  = binand(shift(Chksum2,1),1)
   XSUM2(2)  = binand(shift(Chksum2,2),1)
   XSUM2(3)  = binand(shift(Chksum2,3),1)
   XSUM2(4)  = binand(shift(Chksum2,4),1)
   XSUM2(5)  = binand(shift(Chksum2,5),1)
   XSUM2(6)  = binand(shift(Chksum2,6),1)
   XSUM2(7)  = binand(shift(Chksum2,7),1)


! **********************************************************************

  ! Data For Write Command and Header for page 3.

                                     ! Header for 3rd 128 bytes
  for I = 0 to 15                    ! Initialize to $00
    Header2(I) = hti("00")
  next I

  Header3(0)   = hti("25")           ! Write Cookie Command = $25, $00
  Header3(1)   = hti("00")
  Header3(2)   = hti("83")           ! Length of the total message -
                                     !    excluding the command bytes
  Header3(3)   = hti("11")           ! Starting Address high byte
  Header3(4)   = hti("00")           ! Starting Address low byte
  Header3(5)   = hti("80")           ! Number bytes of Cookie,128 bytes

! **********************************************************************

  for I = 0 to 7                                      ! Header
   HDR3(I*16+0)  = binand(shift(Header3(I*2),0),1)
   HDR3(I*16+1)  = binand(shift(Header3(I*2),1),1)
   HDR3(I*16+2)  = binand(shift(Header3(I*2),2),1)
   HDR3(I*16+3)  = binand(shift(Header3(I*2),3),1)
   HDR3(I*16+4)  = binand(shift(Header3(I*2),4),1)
   HDR3(I*16+5)  = binand(shift(Header3(I*2),5),1)
   HDR3(I*16+6)  = binand(shift(Header3(I*2),6),1)
   HDR3(I*16+7)  = binand(shift(Header3(I*2),7),1)
   HDR3(I*16+8)  = binand(shift(Header3(I*2+1),0),1)
   HDR3(I*16+9)  = binand(shift(Header3(I*2+1),1),1)
   HDR3(I*16+10) = binand(shift(Header3(I*2+1),2),1)
   HDR3(I*16+11) = binand(shift(Header3(I*2+1),3),1)
   HDR3(I*16+12) = binand(shift(Header3(I*2+1),4),1)
   HDR3(I*16+13) = binand(shift(Header3(I*2+1),5),1)
   HDR3(I*16+14) = binand(shift(Header3(I*2+1),6),1)
   HDR3(I*16+15) = binand(shift(Header3(I*2+1),7),1)
  next I

! **********************************************************************
! ************************ CheckSum Calculation ************************
! **********************************************************************

   ! For 3rd 128 bytes

   Chksum3 = 0                                  ! initialize to 0
   EE_Data3 = 0
   for I =  0 to 15                             ! Header
     Chksum3 = Chksum3 + binand(Header3(I),255)
   next I

   for I = 0 to 127                             ! Cookie data

      EE_DD3$ =""
      for G = 0 to 7
         B = (I * 8) + 7 - G
!        B = (I * 8) + G
         EE_DD3$ = EE_DD3$ & val$(EE_D3(B))
      next G

      EE_Data3 = bti(EE_DD3$)

   Chksum3 = Chksum3 + binand(EE_Data3,255)

   next I

   if Chksum3 > 65535 then Chksum3 = binand(Chksum3,65535)

   Chksum3   = bineor(Chksum3,255)  ! XOR with $FF, inverting data
   Chksum3   = binand(Chksum3,255)  ! Lower 8 bits only

   XSUM3(0)  = binand(shift(Chksum3,0),1)             ! Checksum
   XSUM3(1)  = binand(shift(Chksum3,1),1)
   XSUM3(2)  = binand(shift(Chksum3,2),1)
   XSUM3(3)  = binand(shift(Chksum3,3),1)
   XSUM3(4)  = binand(shift(Chksum3,4),1)
   XSUM3(5)  = binand(shift(Chksum3,5),1)
   XSUM3(6)  = binand(shift(Chksum3,6),1)
   XSUM3(7)  = binand(shift(Chksum3,7),1)

! **********************************************************************
! ***************** Print Out Entry Data For EEPROM ********************
! ************************** For Debug Only ****************************
! **********************************************************************

Eprom_Debug = False
!if Eprom_Debug then   ! Change to 'if not.....' to print

    assign @EE_data1_Sprom to "EE_Data1_Hex_Sprom";write
    assign @EE_data2_Sprom to "EE_Data1_Chr_Sprom";write

    for K = 0 to 127  !First 1k
      Char_Data$=""
      for G = 0 to 7
!        B = (K * 8) + G
         B = (K * 8) + 7 - G
         Char_Data$=Char_Data$ & val$(EE_D1(B))
      next G
      Int_Data  = bti ( Char_Data$)
      Hex_Data$ = ith$(Int_Data)
      if len (Hex_Data$ ) =1 then Hex_Data$="0"&Hex_Data$

      ! Output to file
      ! EE_data1 addr and data in hex
      output @EE_data1_Sprom;"   ADDR: " & ith$(K) & "='" & Hex_Data$ & "'"
      !print "   ADDR: " & ith$(K) & "='" & Hex_Data$ & "'"

      ! EE_data2 addr and data in integers and chracters
      !if ((Int_Data < 123) and (Int_Data > 29)) then !!num 30-122 Char 0 to z
      !output @EE_data2_Sprom;"  ADDR: " & val$(K) & "='" & chr$(Int_Data) & "'"
      ! print "   ADDR: " & val$(K) & "='" & chr$(Int_Data) & "'"
      !else
      !output @EE_data2_Sprom;"  ADDR: " & val$(K) & "='" & ith$(Int_Data) & "'"
      ! print "   ADDR: " & val$(K) & "='" & ith$(Int_Data) & "'"
      !end if

    next K

    for K = 128 to 255  !second 1k
      Char_Data$=""
      for G = 0 to 7
!        B = ((K-128) * 8) + G
         B = ((K-128) * 8) + 7 - G
         Char_Data$=Char_Data$ & val$(EE_D2(B))
      next G
      Int_Data  = bti ( Char_Data$)
      Hex_Data$ = ith$(Int_Data)
      if len (Hex_Data$ ) =1 then Hex_Data$="0"&Hex_Data$

      ! Output to file
      ! EE_data1 addr and data in hex
      output @EE_data1_Sprom;"   ADDR: " & ith$(K) & "='" & Hex_Data$ & "'"
      !print "   ADDR: " & ith$(K) & "='" & Hex_Data$ & "'"

      ! EE_data2 addr and data in integers and chracters
      !if ((Int_Data < 123) and (Int_Data > 29)) then !!num 30-122 Char 0 to z
      !output @EE_data2_Sprom;"  ADDR: " & val$(K) & "='" & chr$(Int_Data) & "'"
      ! print "   ADDR: " & val$(K) & "='" & chr$(Int_Data) & "'"
      !else
      !output @EE_data2_Sprom;"  ADDR: " & val$(K) & "='" & ith$(Int_Data) & "'"
      ! print "   ADDR: " & val$(K) & "='" & ith$(Int_Data) & "'"
      !end if

    next K

    for K = 256 to 383  !Third 1k
      Char_Data$=""
      for G = 0 to 7
!        B = ((K-256) * 8) + G
         B = ((K-256) * 8) + 7 - G
         Char_Data$=Char_Data$ & val$(EE_D3(B))
      next G
      Int_Data  = bti ( Char_Data$)
      Hex_Data$ = ith$(Int_Data)
      if len (Hex_Data$ ) =1 then Hex_Data$="0"&Hex_Data$

      ! Output to file
      ! EE_data1 addr and data in hex
      output @EE_data1_Sprom;"   ADDR: " & ith$(K) & "='" & Hex_Data$ & "'"
      !print "   ADDR: " & ith$(K) & "='" & Hex_Data$ & "'"

      ! EE_data2 addr and data in integers and chracters
      !if ((Int_Data < 123) and (Int_Data > 29)) then !!num 30-122 Char 0 to z
      !output @EE_data2_Sprom;"  ADDR: " & val$(K) & "='" & chr$(Int_Data) & "'"
      ! print "   ADDR: " & val$(K) & "='" & chr$(Int_Data) & "'"
      !else
      !output @EE_data2_Sprom;"  ADDR: " & val$(K) & "='" & ith$(Int_Data) & "'"
      ! print "   ADDR: " & val$(K) & "='" & ith$(Int_Data) & "'"
      !end if

    next K

    assign @EE_data1_Sprom to *
    assign @EE_data2_Sprom to *
!end if
subend


sub Chklength_S(Temp2$,Length) !! For PN Only
  global Option
  ChkLen_S:
    if len(Temp2$) < Length then !this pads 0's to back of hex word
       Temp2$= Temp2$&"\"   !these are the 8 bit hex equiv of Ascii chars
       goto ChkLen_S
    end if
subend


sub Read_EEprom
   global Serial$,Act2EprPath$
   global Act2_Vendor$
   dim Read_Data(0:4095)
   !! Start read out board 1 EEprom data
   print tab(7);"Dumping data to Hex file-->" &"EE_Data1_Hex_"&Serial$[1;11]
   print tab(7);"Dumping data to Charfile-->" &"EE_Data1_Chr_"&Serial$[1;11]
   assign @EE_data1 to Act2EprPath$&"\EE_Data_Hex_"&Serial$[1;11];write
   assign @EE_data2 to Act2EprPath$&"\EE_Data_Chr_"&Serial$[1;11];write

      safeguard cool
      test Act2_Vendor$&"/act2%dump";Read_Data(*)
      !Convert Data Array to Data String
       for K = 0 to 511
        Char_Data$=""
        for G = 0 to 7
!          B = (K * 8) + 7 - G
           B = (K * 8) + G
           Char_Data$=Char_Data$ & val$(Read_Data(B))
        next G
        Int_Data  = bti ( Char_Data$)
        Hex_Data$ = ith$(Int_Data)
        if len (Hex_Data$ ) =1 then Hex_Data$="0"&Hex_Data$
        ! Output to file
        ! EE_data1 addr and data in hex
        output @EE_data1;"   ADDR: " & ith$(K) & "='" & Hex_Data$ & "'"
        ! EE_data2 addr and data in integers and chracters
        if ((Int_Data < 123) and (Int_Data > 29)) then !!num 30-122 Char 0 to z
         output @EE_data2;"   ADDR: " & val$(K) & "='" & chr$(Int_Data) & "'"
        else
         output @EE_data2;"   ADDR: " & val$(K) & "='" & ith$(Int_Data) & "'"
        end if
      next K
      assign @EE_data1 to *
      assign @EE_data2 to *
subend

!****************************************************
def fn CheckAct2Programed(Serial_Number$)
    global Act2$,Act2_ch1,Act2_ch2,Act2_ch3
    global Act2_Vendor$,Act2EprPath$
    dim Read_Data(0:63)
    Act2ProFileExists = 9999
    Act2Response = 9999
    Act2Programmed = 9999

    SN$ =Serial_Number$[1;11]
    print SN$
   !the check  whether the boards have been programmed
    assign @Hex_file, Error1 to Act2EprPath$&"\EE_Data_Hex_"&SN$;read

    if Error1 = 100009 then
        print "ACT2 not programmed !"
        Act2ProFileExists = 0
!      assign @Hex_file to *
   end if
   if Error1 = 0 then
       print "ACT2 have programmed !"
       Act2ProFileExists = 1
       assign @Hex_file to *
   end if
    if Error1 <>0 and Error1 <>100009 then
        print errm$
        !others error stop it in test section part  ???
        Act2ProFileExists = 2
        assign @Hex_file to *
    end if

 ! assign @Hex_file to *

  !the below check whether the act2 have response

   Bfailed=boardfailed
   Rpt_lvl$=rli$
   report level is none
   Log_lvl$=lli$
   log level is all !none

   safeguard cool

   test "digital/act2%capture_id";Read_Data(*)

   for K = 0 to 2  !3 Bytes
     Char_Data$=""
     for G = 0 to 7
       B = (K * 8) + G
       Char_Data$=Char_Data$ & val$(Read_Data(B))
     next G
     Int_Data  = bti(Char_Data$)
     Hex_Data$ = Hex_Data$&ith$(Int_Data)
   next K

   print tab(5); "capture act2 ID: "; Hex_Data$

   if Hex_Data$ = "3201C" then
      Act2_Vendor$ = "act2_st"
   else
      if Hex_Data$ = "0313" then
      Act2_Vendor$ = "digital"
    else
       if Hex_Data$ = "361B" then
       Act2_Vendor$ = "act2_q2"   !361B
      else
    !   if Hex_Data$ = "8000" then
          Act2_Vendor$ = "act2_q2" !no response ,maybe locked or defective part
    !    else
    !     print "New device ID: "& Hex_Data$ &", need check !!!"
    !     stop
    !   end if
       end if
     end if
   end if

   call Verify_EEprom

   test Act2_Vendor$&"/act2"  !Don't comment this test ,it's important
   print tab(5); Act2_Vendor$&"/act2";dutfailed
   if dutfailed then
      Act2Response =  0  !no response ,maybe locked or defective part or NTF
   else
       Act2Response = 1  !respsoned ,not locked
   end if

   if Act2Response = 1 then  !normal program
       if Act2_Vendor$ = "digital" or Act2_Vendor$ = "act2_st" then
       Act2Programmed = 0
       end if
   end if

   if Act2Response = 1 and Act2_Vendor$ = "act2_q2" and Act2ProFileExists = 0 then
         Act2Programmed = 0
   end if

   if Act2Response = 1 and Act2_Vendor$ = "act2_q2" and Act2ProFileExists = 1 then
   question ">>Tech check board wheth is from debug and replace ACT2...(y/n)",Ans
   if Ans then
      Act2Programmed = 0
   else

ENTER1:
     input "please input Tech ID:",TechID
       if TechID = 12345 or TechID = 123456 then
       print "the board is rework Q2 board"
     else
       print "Pls re-input TechID:"
       goto ENTER1
     end if

    Act2Programmed = 1
    Act2_ch1 = 1
    Act2_ch2 = 1
    Act2_ch3 = 1
   end if
   end if

  if Act2Response =0 and Act2ProFileExists = 0 then !no respond and no log
     print "your choose wrong ACT2 or place different ACT2 board or ACT2 is bad"
     fail device
     wait 3
     call Disconnect_Power_On_Board
  end if

  if Act2Response =0 and Act2ProFileExists = 1 then !skiped the program and read
      Act2Programmed = 1
      Act2_ch1 = 1
      Act2_ch2 = 1
      Act2_ch3 = 1
   end if

  if Act2Response =0 and Act2ProFileExists = 2 then !need manual check
      Act2Programmed = 2
   end if

 if not Bfailed and not dutfailed then clear failures

  !to restore the report level and log level
  if Rpt_lvl$ = "all" then report level is all
  if Rpt_lvl$ = "none"  then report level is none
  if Rpt_lvl$ = "log" then report level is log
  if Rpt_lvl$ = "report" then report level is report

  if Log_lvl$ = "none"  then log level is all  !log level is non  !changed by tool
  if Log_lvl$ = "manual" then log level is all  !log level is manua  !changed by tool
  if Log_lvl$ = "board"  then log level is all  !log level is boar  !changed by tool
  if Log_lvl$ = "failures" then log level is all  !log level is failure  !changed by tool
  if Log_lvl$ = "analog" then log level is all  !log level is analo  !changed by tool
  if Log_lvl$ = "indictments" then log level is all  !log level is indictment  !changed by tool
  if Log_lvl$ = "all"   then log level is all

  !to clear the failure record
  if dutfailed and not Bfailed then
  clear failures
  end if
  return Act2Programmed

fnend

!//////////////////////////////////////////////////////////////////////
sub CheckAct2Log
    global Serial$,Act2EprPath$
    global Act2_log,Act2_ch1,Act2_ch2,Act2_ch3
    Act2ProFileExists = 9999

    SN$ = Serial$[1;11]
    print SN$
!!  assign @Hex_file, Error1 to Act2EprPath$&"\EE_Data_Hex_"&SN$;read

   !the check  whether the boards have been programmed
    if Error1 = 100009 then
        print "ACT2 not programmed !"
        Act2_log = 0
!!      assign @Hex_file to *
       print "NO programming log generate, please check by technician!!!!!"
   end if

   if Error1 = 0 and Act2_ch1 and Act2_ch2 and Act2_ch3 then
       print "ACT2 have programmed !"
       Act2_log=1
!!     assign @Hex_file to *
   else
CCCCCCCCCC:
       print tab(5);chr$(27)& "&v2S you have comment programming Act2,please input TechID"
       input "TechID:",TechID
       if TechID = 23456789 then
          Act2_log=1
!!        assign @Hex_file to *
       else
           goto CCCCCCCCCC
       end if
   end if

    if Error1 <>0 and Error1 <>100009 then
        print errm$
        !others error stop it in test section part  ???
        Act2_log = 0
!!      assign @Hex_file to *
        print "NO programming log generate, please check by technician!!!!!"
    end if
subend
sub Tup(Device_test$, Count) ! Test until passes or loop exceeds count
global Report_Printer$, Logging
global Report_level$, Log_level$

    Bfailed=boardfailed
    Rpt_lvl$=rli$
    report level is none
    Log_lvl$=lli$       !Apply for debug.                        !02/19/2000
    log level is all!none                                            !02/19/2000

    Lcount=1
    loop
!     if Lcount=2 then
!       print tab(8);"...Retesting ";Device_test$
!     end if
!     if Lcount = 1 then
!        call Msgtest(Device_test$)
!     else
!!        test Device_test$            !!comment for series 6
!     end if
      exit if not dutfailed or Lcount > Count
      Lcount=Lcount +1
    end loop

    if not Bfailed and not dutfailed then clear failures

!#  if Rpt_lvl$="report" then
!#    report level is report
!#  else
!#    if Rpt_lvl$="all" then
!#       report level is all
!#    else
!#      if Rpt_lvl$="log" then report level is log
!#    end if
!#  end if

    if Rpt_lvl$ = "all" then report level is all                  !02/19/2000
    if Rpt_lvl$ = "none" then report level is none                !02/19/2000
    if Rpt_lvl$ = "log" then report level is log                  !02/19/2000
    if Rpt_lvl$ = "report" then report level is report            !02/19/2000

                                                        !Apply for debug.
    if Log_lvl$ = "failures" then log level is all  !log level is failures           !02/19/200  !changed by tool
    if Log_lvl$ = "none" then log level is all  !log level is none                   !02/19/200  !changed by tool
    if Log_lvl$ = "all" then log level is all                     !02/19/2000

    if Logging then                                               !02/19/2000
       call Set_Log_Level                                         !02/19/2000
    end if                                                        !02/19/2000

    if dutfailed then
      if not Bfailed then
        clear failures
        test Device_test$
      else
        test Device_test$
      end if
    end if

subend

sub Dual_test(Test1$,Test2$)

   Oldboardfailed = boardfailed   ! save previous fail status
   Rpt_lvl$=rli$
   report level is none

   OldLL$ = lli$
!   log level is none
     log level is all

  call Tup(Test1$,3)

   if OldLL$ = "all"   then
      log level is all
   else
      if OldLL$ = "analog" then
         log level is all  !log level is analog without nhls, pin  !changed by tool
      else
         if OldLL$ = "failures" then
             log level is all  !log level is failures without nhls, pin  !changed by tool
         else
            if OldLL$ = "none" then
!               log level is none
     log level is all
            else
              log level is all
            end if
         end if
      end if
   end if

   if Rpt_lvl$="report" then
      report level is report
    else
      if Rpt_lvl$="all" then
         report level is all
      else
        if Rpt_lvl$="log" then report level is log
      end if
    end if

 if dutfailed then
    clear failures
    print "      ... Testing "& Test2$
    test Test2$
 else
    print "      ... Testing "& Test1$
    test Test1$
 end if
   if Oldboardfailed then fail device
subend


!@sub Bucle_Act(Cantidad,Tiempo)
!@  faon
!@  for X = 1 to Cantidad
!@    faoff Tiempo
!@    faon
!@  next X
!@subend



sub Print_board_testing_msg
 global Fab$, Bom$, Board$, Board_Rev$, Board_Name$, Serial$, Assembly$
 global Red$, Blue$

  !#!Color          a/x    b/y   c/z
  !#!----------     ---    ---   ---
  !#!Black           0      0     0
  !#!Blue            0      0     1
  !#!Green           0      1     0
  !#!Cyan            0      1     1
  !#!Red             1      0     0
  !#!Magenta         1      0     1
  !#!Yellow          1      1     0
  !#!White           1      1     1
  !#!
  !#!a,b,c: foreground
  !#!x,y,z: background
  !#!#I: pen number (0-7); try NOT to use pen #0
  !#
  !#!print chr$(27)&"&v1a1b1c1x0y1z7I"
  !#!print chr$(27)&"&v1a1b1c0x0y1z7I"
  !#!print chr$(27)&"&v1a1b1c.7x0y.4z7I"
  !#
  !#PEN_6:  !# blue on yellow
  !#print chr$(27)&"&v0a0b1c1x1y0z6I"
  !#
  !#PEN_7:
  !#print chr$(27)&"&v1a1b1c.9x0y.5z7I"
  !#print tab(5);chr$(27)&"&v7S"&BoardMsg$

  print tab(9);chr$(27)&"&v7S  ---------------------------------------------- "
  print tab(9);chr$(27)&"&v7S     ICT Program Developed by B29 ICT Group      "
  print tab(9);chr$(27)&"&v7S  ---------------------------------------------- "
  print"                                                                      "
  print tab(5);Blue$&"                 _                       _               "
  print tab(5);Blue$&"                | |                     | |              "
  print tab(5);Blue$&"                | |                     | |              "
  print tab(5);Blue$&"           _    | |    _           _    | |    _         "
  print tab(5);Blue$&"          | |   | |   | |         | |   | |   | |        "
  print tab(5);Blue$&"     _    | |   | |   | |    _    | |   | |   | |    _   "
  print tab(5);Blue$&"    | |   | |   | |   | |   | |   | |   | |   | |   | |  "
  print tab(5);Blue$&"    |_|   |_|   | |   |_|   |_|   |_|   | |   |_|   |_|  "
  print tab(5);Blue$&"                |_|                     |_|              "
  print tab(5);Blue$&"                                                         "
  print tab(5);Red$&"             CCC    IIII     SSS      CCC      OOO        "
  print tab(5);Red$&"            C        II     S        C        O   O       "
  print tab(5);Red$&"            C        II      SS      C        O   O       "
  print tab(5);Red$&"            C        II        S     C        O   O       "
  print tab(5);Red$&"             CCC    IIII    SSS       CCC      OOO        "
  print"                                                                      "
  print tab(11);chr$(27)&"&v7S  -------------------------------------- "
  print tab(11);chr$(27)&"&v7S          TESTING "&Board_Name$&"                "
  print tab(11);chr$(27)&"&v7S      No. Parte: "&Assembly$&"          "
  print tab(11);chr$(27)&"&v7S         SERIAL: "&Serial$&"             "
  print tab(11);chr$(27)&"&v7S  -------------------------------------- "
  print"                                                               "
subend



sub FF_Val(Serial$, Flex_Flow)
global FL, Serial_golden$,StopLine$

Result$ = ""
StopLine$ = ""

if Serial_golden$ = "unidad golden" then goto Gold

   execute "ffeticlient -VERIFY "&Serial$, Error;nowait
   enter "ffeticlient.out";Result$
   print Result$

B=len(Result$)

if Result$[B-10;11] = "StopLineICT" then
   StopLine$ = "1"
   print ""
   print tab(5),Red$&"STOPLINE ACTIVO, VALIDA QUE LA UNIDAD SEA LA CORRECTA PARA PROBAR"
   print ""
   print tab(18),Black$&"VALIDA QUE LA UNIDAD ESTE BIEN COLOCADA"
   print ""
   goto Line
end if
           if Result$[1;2]="{O" then
              print chr$(27)&"&v2SValidacion en Flex_Flow OK"
              FL = 0
           else
              print chr$(27)&"&v1SEsta tarjeta no pertenece a esta estacion"
              FL = 1
           end if

Gold:

subend

sub Counter
  global Fix_Type$
  execute "C:\\counter\\counter.exe "& Fix_Type$;append
  wait 1
subend

 !###########           RUTINA OPERADORES  NEW    #############
sub Checa_operador
global Oper$

loop

P$ = "C:\Operator\Operator.txt"
assign @Ver_oper,Error to P$; read, exclusive

if Error <> 100009 then
  assign @Ver_Oper to P$; read, exclusive  !Vuelve a leer el Archivo
  enter @Ver_Oper; Oper$
  assign @Ver_Oper to *
  goto OP
end if

  print tab(16);chr$(27)&"&v4S--------------------------------------------"
  print tab(16);chr$(27)&"&v1S    -----------------------------------     "
  print tab(16);chr$(27)&"&v1S    |      NO SE PUEDE CONTINUAR      |     "
  print tab(16);chr$(27)&"&v1S    |      OPERADOR NO CERTIFICADO    |     "
  print tab(16);chr$(27)&"&v1S    -----------------------------------     "
  print tab(16);chr$(27)&"&v4S--------------------------------------------"

  print tab(21);chr$(27)&"&v6S Enter a certified Operator"

  wait 2000m
  print using "@"

end loop

OP:
subend

!###########           RUTINA OPERADORES  NEW    #############
!#############################################################################
sub Check_board
global Red$, Yellow$

 print
 print tab(13);Yellow$&"****** FAVOR DE REVISAR LA UNIDAD  *********"
 print tab(13);Yellow$&"****** ESTE COLOCADA CORRECTAMENTE ****************"
 print

subend
!#############################################################################


sub Verify_EEprom                         !todas las subrutinas se mandan al final del testplan
global Serial$,Board$,Red$,Green$,Act2_Vendor$
dim Read_Data(16384)
!dim Read_Data(0:1024)
   !! Start read out board 1 EEprom data

   assign @EE_data1 to "Hex";write
   assign @EE_data2 to "Char";write

   safeguard cool
   test Act2_Vendor$&"/act2%dump";Read_Data(*)
     for K = 0 to 511    !4096
     Char_Data$=""
     for G = 0 to 7
        B = (K * 8) + G
        Char_Data$=Char_Data$ & val$(Read_Data(B))
     next G
     Int_Data  = bti ( Char_Data$)
     Hex_Data$ = ith$(Int_Data)
     if len (Hex_Data$ ) =1 then Hex_Data$="0"&Hex_Data$

     ! Output to file
     ! EE_data1 addr and data in hex
     output @EE_data1;"   ADDR: " & ith$(K) & "='" & Hex_Data$ & "'"

     ! EE_data2 addr and data in integers and chracters
     if ((Int_Data < 123) and (Int_Data > 29)) then !!num 30-122 Char 0 to z
      output @EE_data2;"   ADDR: " & val$(K) & "='" & chr$(Int_Data) & "'"
     else
      output @EE_data2;"   ADDR: " & val$(K) & "='" & ith$(Int_Data) & "'"
     end if

   next K

      assign @EE_data1 to *
      assign @EE_data2 to *

   execute"read_pcamap.1.1.exe",Err;nowait,append
   wait 500m

!@   enter "Hex.out";Hexout$
!@if Hexout$[1;2] = "FF" or  Hexout$[1;2] = "00" then
!@   print ""
!@   print Green$&"PRIMERA VEZ QUE SE PRUEBA LA UNIDAD"
!@   log "}"
!@   log "{@D-T|0|384||0|EEPROM PRIMERA VEZ QUE SE PROGRAMARA"
!@   goto Ensa
!@end if
!@
!@if Hexout$= Assembly$ then
!@   print ""
!@   printGreen$&"EL NUMERO DE SERIE COINCIDE CON LA PCB"
!@   log "}"
!@   log "{@D-T|0|384||0|EEPROM VALIDACION P\N PASS"
!@else
!@   printRed$&"EL NUMERO PARTE NO COINCIDE CON LA PCB"
!@   printRed$&"LLAMEN AL DEPARTEMENTO DE PRUEBAS Y A SU SUPERVISOR"
!@   call Mala_Operacion
!@   stop
!@end if
!@Ensa:

   enter "Char.out";Charout$
if Charout$[1;11] = "FFFFFFFFFFF" or Charout$[1;11] = "00000000000" then
   print tab(5),Green$&"PRIMERA VEZ QUE SE PROGRAMARA"
   log "}"
   log "{@D-T|0|384||0|EEPROM PRIMERA VEZ QUE SE PROGRAMARA"
   goto Primera
end if

if Charout$= Serial$ then
   print tab(5),Green$&"EL NUMERO DE SERIE ESCANEADO COINCIDE CON EL DE LA PCB"
   log "}"
   log "{@D-T|0|384||0|EEPROM VALIDACION DE S\N PASS"
else
   print ""
   print Red$&"EL NUMERO DE SERIE ESCANEADO NO COINCIDE CON EL DE LA PCB"
   print Red$&"LLAMA AL DEPARTAMENTO DE PRUEBAS Y A SU SUPERVISOR"
   print Red$&"INFO EN LA EEPROM: "& Charout$
   call Mala_Operacion                        !@Asegurate de copiar tambien esta subrutina que es
   call Disconnect_Power_On_Board
   auxdisconnect 5
   faoff
   unpowered
   stop                                       !@la que hace el registro del operador que cometio el error
end if

Primera:

subend


sub Mala_Operacion
global P$,Serial$,Charout$
global Assembly$,Oper$

P$ = "F:\Registro\Mala_Operacion.txt"
assign @Operador,Error to P$; read, exclusive

assign @Unidades to P$; write, append   !Vuelve a leer el Archivo
output @Unidades; Assembly$,Serial$,Charout$,Oper$,datetime$
assign @Unidades to *

subend
